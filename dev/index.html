<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>TelecomUtils.jl · TelecomUtils</title><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>TelecomUtils</a></span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>TelecomUtils.jl</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>TelecomUtils.jl</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>TelecomUtils.jl</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/disberd/TelecomUtils.jl/blob/master/docs/src/index.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="TelecomUtils.jl"><a class="docs-heading-anchor" href="#TelecomUtils.jl">TelecomUtils.jl</a><a id="TelecomUtils.jl-1"></a><a class="docs-heading-anchor-permalink" href="#TelecomUtils.jl" title="Permalink"></a></h1><p>Documentation for TelecomUtils.jl</p><article class="docstring"><header><a class="docstring-binding" id="TelecomUtils.DVBS2x" href="#TelecomUtils.DVBS2x"><code>TelecomUtils.DVBS2x</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DVBS2x &lt;: CapacityComputationType</code></pre><p>Structure used to dispatch on <code>speff2snr</code> and <code>snr2speff</code> to simulate the MODCODs of the DVB-S2x air interface.</p><p><strong>Note</strong></p><p>The threshold values are taken from the error performance chapter (6) of the <a href="https://dvb.org/?standard=second-generation-framing-structure-channel-coding-and-modulation-systems-for-broadcasting-interactive-services-news-gathering-and-other-broadband-satellite-applications-part-2-dvb-s2-extensions">DVB-S2x  standard</a> assuming AWGN conditions</p><p>See also: <a href="#TelecomUtils.Shannon"><code>Shannon</code></a>, <a href="#TelecomUtils.NR5G"><code>NR5G</code></a>, <a href="#TelecomUtils.speff2snr-Tuple{DVBS2x, Any}"><code>speff2snr</code></a>, <a href="#TelecomUtils.snr2speff-Tuple{DVBS2x, Any}"><code>snr2speff</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/disberd/TelecomUtils.jl/blob/298af29cfbedee573e0fb7f70ddae3f180392cfa/notebooks/snr2speff.jl#L56-L63">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TelecomUtils.ECEFfromENU" href="#TelecomUtils.ECEFfromENU"><code>TelecomUtils.ECEFfromENU</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Convert a point from ENU coordinates to ECEF ones</p><p><strong>Fields</strong></p><ul><li><code>origin::SVector{3,Float64}</code>: ECEF coordinates of the reference CRS origin</li><li><code>R::RotMatrix3{Float64}</code>: Rotation matrix to align the source to the destination CRS axes</li><li><code>ellipsoid::Ellipsoid{Float64}</code>: Reference ellipsoid used for the transformation between ECEF and other coordinates</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/disberd/TelecomUtils.jl/blob/298af29cfbedee573e0fb7f70ddae3f180392cfa/notebooks/refview_transformations.jl#L137-L144">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TelecomUtils.ECEFfromERA" href="#TelecomUtils.ECEFfromERA"><code>TelecomUtils.ECEFfromERA</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Convert a point from ERA coordinates to ECEF ones</p><p><strong>Fields</strong></p><ul><li><code>origin::SVector{3,Float64}</code>: ECEF coordinates of the reference CRS origin</li><li><code>R::RotMatrix3{Float64}</code>: Rotation matrix to align the source to the destination CRS axes</li><li><code>ellipsoid::Ellipsoid{Float64}</code>: Reference ellipsoid used for the transformation between ECEF and other coordinates</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/disberd/TelecomUtils.jl/blob/298af29cfbedee573e0fb7f70ddae3f180392cfa/notebooks/refview_transformations.jl#L137-L144">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TelecomUtils.ECEFfromUV" href="#TelecomUtils.ECEFfromUV"><code>TelecomUtils.ECEFfromUV</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Convert a point from UV coordinates to ECEF ones</p><p><strong>Fields</strong></p><ul><li><code>origin::SVector{3,Float64}</code>: ECEF coordinates of the reference CRS origin</li><li><code>R::RotMatrix3{Float64}</code>: Rotation matrix to align the source to the destination CRS axes</li><li><code>ellipsoid::Ellipsoid{Float64}</code>: Reference ellipsoid used for the transformation between ECEF and other coordinates</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/disberd/TelecomUtils.jl/blob/298af29cfbedee573e0fb7f70ddae3f180392cfa/notebooks/refview_transformations.jl#L137-L144">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TelecomUtils.ENUfromECEF" href="#TelecomUtils.ENUfromECEF"><code>TelecomUtils.ENUfromECEF</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Convert a point from ECEF coordinates to ENU ones</p><p><strong>Fields</strong></p><ul><li><code>origin::SVector{3,Float64}</code>: ECEF coordinates of the reference CRS origin</li><li><code>R::RotMatrix3{Float64}</code>: Rotation matrix to align the source to the destination CRS axes</li><li><code>ellipsoid::Ellipsoid{Float64}</code>: Reference ellipsoid used for the transformation between ECEF and other coordinates</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/disberd/TelecomUtils.jl/blob/298af29cfbedee573e0fb7f70ddae3f180392cfa/notebooks/refview_transformations.jl#L137-L144">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TelecomUtils.ERA" href="#TelecomUtils.ERA"><code>TelecomUtils.ERA</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Elevation, Range and Azimuth for a target point on space as seen from a source point on or above the earth surface</p><p><strong>Fields</strong></p><ul><li><code>el::Float64</code>: Elevation view angle (<code>0 &lt;= el &lt;= π/2</code>) between source and target point [rad].</li><li><code>r::Float64</code>: Range (<code>r &gt;= 0</code>) between the source and target points [m].</li><li><code>az::Float64</code>: Azimuth view angle between source and target point [rad], computed from West to North from the source point perspective. Values provided are automatically converted between -π and π</li></ul><p><strong>Constructors</strong></p><pre><code class="nohighlight hljs">ERA(el::ValidAngle,r::ValidDistance,az::ValidAngle)</code></pre><p><code>ValidAngle</code> is a either a Real number or a <code>Unitful.Quantity</code> of unit either <code>u&quot;rad&quot;</code> or <code>u&quot;°&quot;</code>.</p><p><code>ValidDistance</code> is either a Real Number, or a subtype of <code>Unitful.Length</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/disberd/TelecomUtils.jl/blob/298af29cfbedee573e0fb7f70ddae3f180392cfa/notebooks/refview_basics.jl#L366-L381">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TelecomUtils.ERAfromECEF" href="#TelecomUtils.ERAfromECEF"><code>TelecomUtils.ERAfromECEF</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Convert a point from ECEF coordinates to ERA ones</p><p><strong>Fields</strong></p><ul><li><code>origin::SVector{3,Float64}</code>: ECEF coordinates of the reference CRS origin</li><li><code>R::RotMatrix3{Float64}</code>: Rotation matrix to align the source to the destination CRS axes</li><li><code>ellipsoid::Ellipsoid{Float64}</code>: Reference ellipsoid used for the transformation between ECEF and other coordinates</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/disberd/TelecomUtils.jl/blob/298af29cfbedee573e0fb7f70ddae3f180392cfa/notebooks/refview_transformations.jl#L137-L144">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TelecomUtils.EarthModel" href="#TelecomUtils.EarthModel"><code>TelecomUtils.EarthModel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">mutable struct EarthModel</code></pre><p>Geometrical model of the Earth ellipsoid to be used for all the view angles between satellite and points on earth.</p><p><strong>Fields</strong></p><ul><li><p><code>ellipsoid::Ellipsoid{Float64}</code></p><p>Ellipsoid structure, used for the various point of view conversion. Default: SphericalEllipsoid()</p></li><li><p><code>geod::Proj4.geod_geodesic</code></p><p>Extended geod structure, used for the inverse geodesic problem to compute distance and azimuth between points on earth. (Relies on GeographicLib). Default: Proj4.geod_geodesic(ellipsoid)</p></li></ul><p>A single instance of this structure should be used for all satellites of a given simulation/constellation.<br/>Changes to any of the two fields (via <code>setproperty!</code>) will trigger an automatic recomputation of the other field.<br/>When called without arguments, it defaults to a spherical earth with a radius of 6371 km.</p><p>See also: <a href="@ref"><code>Ellipsoid</code></a>, <a href="#TelecomUtils.SphericalEllipsoid"><code>SphericalEllipsoid</code></a>, <a href="@ref"><code>SatView</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/disberd/TelecomUtils.jl/blob/298af29cfbedee573e0fb7f70ddae3f180392cfa/notebooks/refview_basics.jl#L141">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TelecomUtils.LLA" href="#TelecomUtils.LLA"><code>TelecomUtils.LLA</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Identify a point on or above earth using geodetic coordinates</p><p><strong>Fields</strong></p><ul><li><code>lat::Float64</code>: Latitude (<code>-π/2 &lt;= lat &lt;= π/2</code>) of the point [rad].</li><li><code>lon::Float64</code>: Longitude of the point [rad].</li><li><code>alt::Float64</code>: Altitude of the point above the reference earth ellipsoid [m].</li></ul><p><strong>Constructors</strong></p><pre><code class="nohighlight hljs">LLA(lat::ValidAngle,lon::ValidAngle,alt::ValidDistance)
LLA(lat::ValidAngle,lon::ValidAngle) # Defaults to 0m altitude</code></pre><p><code>ValidAngle</code> is a either a Real number or a <code>Unitful.Quantity</code> of unit either <code>u&quot;rad&quot;</code> or <code>u&quot;°&quot;</code>.</p><p><code>ValidDistance</code> is either a Real Number, or a subtype of <code>Unitful.Length</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/disberd/TelecomUtils.jl/blob/298af29cfbedee573e0fb7f70ddae3f180392cfa/notebooks/refview_basics.jl#L447-L462">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TelecomUtils.LLAfromUV" href="#TelecomUtils.LLAfromUV"><code>TelecomUtils.LLAfromUV</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Convert a point from UV coordinates to LLA ones</p><p><strong>Fields</strong></p><ul><li><code>origin::SVector{3,Float64}</code>: ECEF coordinates of the reference CRS origin</li><li><code>R::RotMatrix3{Float64}</code>: Rotation matrix to align the source to the destination CRS axes</li><li><code>ellipsoid::Ellipsoid{Float64}</code>: Reference ellipsoid used for the transformation between ECEF and other coordinates</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/disberd/TelecomUtils.jl/blob/298af29cfbedee573e0fb7f70ddae3f180392cfa/notebooks/refview_transformations.jl#L137-L144">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TelecomUtils.NR5G" href="#TelecomUtils.NR5G"><code>TelecomUtils.NR5G</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">NR5G &lt;: CapacityComputationType</code></pre><p>Structure used to dispatch on <code>speff2snr</code> and <code>snr2speff</code> to simulate the MODCODs of the 5G NR air interface.</p><p><strong>Note</strong></p><p>The thresholds for the 5G approximation are taken from a document by Intel that can be found at <a href="https://www.3gpp.org/ftp/TSG_RAN/WG1_RL1/TSGR1_90/Docs/R1-1712553.zip">this link</a>. The document present a picture of the spectral efficiency vs SNR for various 5G NR MODCODs.</p><p>As the tabular data is not provided in the document, the points are extrapolated from the image using <a href="https://automeris.io/WebPlotDigitizer/">this tool</a>. </p><p>The thresholds extrapolated from the image with the tool are increased by 1dB, since the values from the picture refer to 10% BLER (Block Error Rate), and we want to use something more akin to QEF (Quasi Error Free) as done for the DVB-S2x thresholds.</p><p><strong>For this reason, the results for <code>snr2speff</code> and <code>speff2snr</code> for the 5G NR waveforms will be a linear interpolation based on the extrapolated values, rather than a step function corresponding to existing MODCODs</strong></p><p>See also: <a href="#TelecomUtils.DVBS2x"><code>DVBS2x</code></a>, <a href="#TelecomUtils.Shannon"><code>Shannon</code></a>, <a href="#TelecomUtils.speff2snr-Tuple{DVBS2x, Any}"><code>speff2snr</code></a>, <a href="#TelecomUtils.snr2speff-Tuple{DVBS2x, Any}"><code>snr2speff</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/disberd/TelecomUtils.jl/blob/298af29cfbedee573e0fb7f70ddae3f180392cfa/notebooks/snr2speff.jl#L67-L81">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TelecomUtils.ReferenceView" href="#TelecomUtils.ReferenceView"><code>TelecomUtils.ReferenceView</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">rv = ReferenceView{T}(lla_or_ecef::Union{LLA, Point3D},earthmodel::EarthModel; kwargs...)</code></pre><p>A <code>ReferenceView</code> instance <code>rv</code> tracks the instantaneous position and orientation of an object in space or on earth. It is used to provide convenience methods to assess pointing, distance and visibility between obejcts. It can also be used to extract 3D coordinates (LLA or ECEF) based on pointing angles from the <code>ReferenceView</code> instance.</p><p>When initializing <code>rv</code>, two convenience aliases can be used:</p><ul><li><code>UserView === ReferenceView{:User}</code> can be used to represent users</li><li><code>SatView === ReferenceView{:Satellite}</code> can be used to represent satellites</li></ul><p>The main difference between the two is that the default local CRS for computing pointing and visibilities is West-North-Down (+Z towards nadir) for <code>SatView</code> while it&#39;s East-North-Up (+Z towards Zenith) for <code>UserView</code>.</p><p><strong>Fields</strong></p><ul><li><p><code>ecef::StaticArraysCore.SVector{3, Float64}</code></p><p>ECEF coordinates of the current satellite position</p></li><li><p><code>lla::LLA</code></p><p>LLA coordinates of the current satellite position</p></li><li><p><code>earthmodel::EarthModel</code></p><p>Reference EarthModel used for the projections and for the geodesic computations</p></li><li><p><code>R::Rotations.RotMatrix3{Float64}</code></p><p>Rotation Matrix to go from the default local CRS to the ECEF CRS</p></li><li><p><code>rot_z::Float64</code></p><p>Rotation angle [rad] about the z axis to bring the default local CRS to the current one</p></li><li><p><code>rot_y::Float64</code></p><p>Rotation angle [rad] about the y axis to bring the default local CRS to the current one</p></li><li><p><code>rot_x::Float64</code></p><p>Rotation angle [rad] about the x axis to bring the default local CRS to the current one</p></li><li><p><code>face::TelecomUtils.Faces</code></p><p>Reference race of the satellite used for the pointing computations</p></li></ul><p>When multiple <code>ReferenceView</code> objects have to be modelled/tracked, the <code>earthmodel</code> field of all of them should point to the same <code>EarthModel</code> instance, so it should be generated once and then passed to the constructor of all the ReferenceView instances to ensure that all the objects are referring to the same earth model.<br/>Doing so will enforce the same Ellipsoid is shared between all satellites even when it is changed from one of the SatView instances.</p><p>To understand how the fields <code>rot_z</code>, <code>rot_y</code> and <code>rot_x</code> are used to model the rotation applied to the default local CRS to the intended one, see the documentation of <a href="#TelecomUtils.crs_rotation-Tuple{}"><code>crs_rotation</code></a></p><p>The possible values for the reference <code>face</code> (defined with respect to the axes of the local CRS) used for pointing/visibility computations can be found looking at <a href="#TelecomUtils.change_reference_face!-Tuple{ReferenceView, Any}"><code>change_reference_face!</code></a></p><p>See also: <a href="#TelecomUtils.change_position!-Tuple{ReferenceView, Any, LLA, Any, Any, Any, Any}"><code>change_position!</code></a>, <a href="#TelecomUtils.change_attitude!-Tuple{ReferenceView}"><code>change_attitude!</code></a>, <a href="#TelecomUtils.change_reference_face!-Tuple{ReferenceView, Any}"><code>change_reference_face!</code></a>, <a href="#TelecomUtils.get_range-Tuple{ReferenceView, Union{Tuple{Number, Number}, StaticArraysCore.StaticArray{Tuple{2}, &lt;:Number, 1}}, TelecomUtils.ExtraOutput}"><code>get_range</code></a>, <a href="#TelecomUtils.get_pointing-Tuple{ReferenceView, Union{LLA, Tuple{Number, Number, Number}, StaticArraysCore.StaticArray{Tuple{3}, &lt;:Number, 1}}, TelecomUtils.ExtraOutput}"><code>get_pointing</code></a>, <a href="#TelecomUtils.get_lla-Tuple{ReferenceView, Union{Tuple{Number, Number}, StaticArraysCore.StaticArray{Tuple{2}, &lt;:Number, 1}}, TelecomUtils.ExtraOutput}"><code>get_lla</code></a>, <a href="#TelecomUtils.get_ecef-Tuple{ReferenceView, Union{Tuple{Number, Number}, StaticArraysCore.StaticArray{Tuple{2}, &lt;:Number, 1}}, TelecomUtils.ExtraOutput}"><code>get_ecef</code></a>, <a href="#TelecomUtils.geod_inverse-Tuple{Proj4.geod_geodesic, AbstractVector{Float64}, AbstractVector{Float64}}"><code>geod_inverse</code></a>, <a href="#TelecomUtils.get_distance_on_earth-Tuple{LLA, LLA, TelecomUtils.ExtraOutput}"><code>get_distance_on_earth</code></a>, <a href="#TelecomUtils.get_nadir_beam_diameter-Tuple{Any, Any}"><code>get_nadir_beam_diameter</code></a>, <a href="@ref"><code>ExtraOutput</code></a>, <a href="#TelecomUtils.get_visibility-Tuple{ReferenceView, Union{LLA, Tuple{Number, Number, Number}, StaticArraysCore.StaticArray{Tuple{3}, &lt;:Number, 1}}, TelecomUtils.ExtraOutput}"><code>get_visibility</code></a>, <a href="#TelecomUtils.get_mutual_visibility-Tuple{ReferenceView, ReferenceView, TelecomUtils.ExtraOutput}"><code>get_mutual_visibility</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/disberd/TelecomUtils.jl/blob/298af29cfbedee573e0fb7f70ddae3f180392cfa/notebooks/refview_struct.jl#L169-L200">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TelecomUtils.Shannon" href="#TelecomUtils.Shannon"><code>TelecomUtils.Shannon</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Shannon &lt;: CapacityComputationType</code></pre><p>Structure used to dispatch on <code>speff2snr</code> and <code>snr2speff</code> to decide the method to use for the computation</p><p>See also: <a href="#TelecomUtils.DVBS2x"><code>DVBS2x</code></a>, <a href="#TelecomUtils.NR5G"><code>NR5G</code></a>, <a href="#TelecomUtils.speff2snr-Tuple{DVBS2x, Any}"><code>speff2snr</code></a>, <a href="#TelecomUtils.snr2speff-Tuple{DVBS2x, Any}"><code>snr2speff</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/disberd/TelecomUtils.jl/blob/298af29cfbedee573e0fb7f70ddae3f180392cfa/notebooks/snr2speff.jl#L85-L90">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TelecomUtils.UVfromECEF" href="#TelecomUtils.UVfromECEF"><code>TelecomUtils.UVfromECEF</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Convert a point from ECEF coordinates to UV ones</p><p><strong>Fields</strong></p><ul><li><code>origin::SVector{3,Float64}</code>: ECEF coordinates of the reference CRS origin</li><li><code>R::RotMatrix3{Float64}</code>: Rotation matrix to align the source to the destination CRS axes</li><li><code>ellipsoid::Ellipsoid{Float64}</code>: Reference ellipsoid used for the transformation between ECEF and other coordinates</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/disberd/TelecomUtils.jl/blob/298af29cfbedee573e0fb7f70ddae3f180392cfa/notebooks/refview_transformations.jl#L137-L144">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TelecomUtils.UVfromLLA" href="#TelecomUtils.UVfromLLA"><code>TelecomUtils.UVfromLLA</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Convert a point from LLA coordinates to UV ones</p><p><strong>Fields</strong></p><ul><li><code>origin::SVector{3,Float64}</code>: ECEF coordinates of the reference CRS origin</li><li><code>R::RotMatrix3{Float64}</code>: Rotation matrix to align the source to the destination CRS axes</li><li><code>ellipsoid::Ellipsoid{Float64}</code>: Reference ellipsoid used for the transformation between ECEF and other coordinates</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/disberd/TelecomUtils.jl/blob/298af29cfbedee573e0fb7f70ddae3f180392cfa/notebooks/refview_transformations.jl#L137-L144">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TelecomUtils.SphericalEllipsoid" href="#TelecomUtils.SphericalEllipsoid"><code>TelecomUtils.SphericalEllipsoid</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">SphericalEllipsoid(r = 6371e3)</code></pre><p>Define a spherical ellipsoid of radius <code>r</code> to be used for the various transformation in <a href="@ref"><code>SatView</code></a>. Defaults to 6371km radius</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/disberd/TelecomUtils.jl/blob/298af29cfbedee573e0fb7f70ddae3f180392cfa/notebooks/refview_basics.jl#L114-L117">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TelecomUtils.add_angular_offset-Tuple{Any, Any}" href="#TelecomUtils.add_angular_offset-Tuple{Any, Any}"><code>TelecomUtils.add_angular_offset</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">p = add_angular_offset(p₀, offset_angles; input_type = :UV, output_type = :UV)
p = add_angular_offset(p₀, θ::ValidAngle, φ::ValidAngle = 0.0; input_type = :UV, output_type = :UV)</code></pre><p>Compute the resulting pointing direction <code>p</code> obtained by adding an angular offset specified by angles θ, φ (following the ISO/Physics convention for spherical coordinates) [rad] to the starting position identified by p₀.</p><p>The input starting position <code>p₀</code> can be specified as any iterable of 2 elements and is interpreted (depending on the value of the <code>input_type</code> kwarg) as a set of 2D coordinates specified either as U-V or Theta-Phi [rad]. </p><p>The output pointing <code>p</code> is always provided as a <code>SVector{2, Float64}</code> and similarly to <code>p₀</code> can be given as either UV or ThetaPhi coordinates depending on the value of the <code>output_type</code> kwarg.</p><p>For both <code>input_type</code> and <code>output_type</code>, the following Symbols are supported:</p><ul><li><code>:thetaphi</code>, <code>:ThetaPhi</code> and <code>:θφ</code> can be used to represent pointing in ThetaPhi</li><li><code>:UV</code> and <code>:uv</code> can be used to represent pointing in UV</li></ul><p>The offset angles can be provided either as 2nd and 3rd argument to the function (2nd method) or as an iterable containing θ and φ as first and second element respectively (1st method).</p><p>This function performs the inverse operation of <a href="#TelecomUtils.get_angular_offset-Tuple{Any, Any}"><code>get_angular_offset</code></a> so the following code should return true</p><pre><code class="language-julia hljs">uv1 = (.3,.4)
uv2 = (-.2,.5)
offset = get_angular_offset(uv1, uv2; input_type = :uv, output_type = :thetaphi)
p = add_angular_offset(uv1, offset; input_type = :uv, output_type = :uv)
all(p .≈ uv2)</code></pre><p>See also: <a href="#TelecomUtils.get_angular_offset-Tuple{Any, Any}"><code>get_angular_offset</code></a>, <a href="#TelecomUtils.get_angular_distance-Tuple{Any, Any}"><code>get_angular_distance</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/disberd/TelecomUtils.jl/blob/298af29cfbedee573e0fb7f70ddae3f180392cfa/notebooks/refview_transformations.jl#L665-L699">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TelecomUtils.change_attitude!-Tuple{ReferenceView}" href="#TelecomUtils.change_attitude!-Tuple{ReferenceView}"><code>TelecomUtils.change_attitude!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">change_attitude!(rv::ReferenceView; rot_z = 0.0, rot_y = 0.0, rot_x = 0.0)</code></pre><p>Modify the attitude (local CRS orientation) of <code>rv</code> by recomputing its internal rotation matrix as a product of the default location based one and the attitude rotation based on <code>rot_z</code>, <code>rot_y</code> and <code>rot_x</code>.</p><p>See <a href="#TelecomUtils.crs_rotation-Tuple{}"><code>crs_rotation</code></a> for details on how the attitude rotation matrix is defined and computed.</p><p>See also <a href="ref"><code>ReferenceView</code></a>, <a href="#TelecomUtils.change_position!-Tuple{ReferenceView, Any, LLA, Any, Any, Any, Any}"><code>change_position!</code></a>, <a href="@ref"><code>change_Reference_face!</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/disberd/TelecomUtils.jl/blob/298af29cfbedee573e0fb7f70ddae3f180392cfa/notebooks/refview_struct.jl#L419-L426">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TelecomUtils.change_position!-Tuple{ReferenceView, Any, LLA, Any, Any, Any, Any}" href="#TelecomUtils.change_position!-Tuple{ReferenceView, Any, LLA, Any, Any, Any, Any}"><code>TelecomUtils.change_position!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">change_position!(rv::ReferenceView, ecef, lla::LLA, R, rot_z, rot_x, rot_y)
change_position!(rv::ReferenceView, ecef::Point3D, lla::LLA; rot_z = 0.0, rot_y = 0.0, rot_x = 0.0)
change_position!(rv::ReferenceView, lla::LLA; rot_z = 0.0, rot_y = 0.0, rot_x = 0.0)
change_position!(rv::ReferenceView, ecef::Point3D; rot_z = 0.0, rot_y = 0.0, rot_x = 0.0)</code></pre><p>Change the position of a <a href="#TelecomUtils.ReferenceView"><code>ReferenceView</code></a> object <code>rv</code>, also returning as output the modified <code>rv</code>.  The function mutates the <code>ecef</code>, <code>lla</code>, <code>R</code>, <code>rot_z</code>, <code>rot_y</code>, <code>rot_x</code> fields of the <code>rv</code> object with the values provided as arguments (when using the 1st method above).<br/>For the remaining methods, the missing arguments are computed automatically.</p><p>One would normally use one of the last 3 methods so that the rotation matrix (and eventually either ECEF or LLA) are correctly computed by the function.</p><p>The first method avoids any computations but does not validate that provided inputs are correct/consistent and refer to the same position in space. For this reason it should only be used if those values are correctly pre-computed elsewhere and one wants to avoid the duplicate computations. </p><p>Note: <code>rot_z</code>, <code>rot_y</code> and <code>rot_x</code> are used to obtain the actual reference CRS to use for the pointing computations. These angles are used to transform the default CRS (which is WND for SatView and ENU for UserView) into the desired CRS. This is done performing a z-y-x <em>intrinsic</em> rotation of the default CRS following the <a href="https://en.wikipedia.org/wiki/Euler_angles#Tait%E2%80%93Bryan_angles">Tait-Bryan Definition</a>.</p><p>See also: <a href="#TelecomUtils.ReferenceView"><code>ReferenceView</code></a>, <a href="#TelecomUtils.get_range-Tuple{ReferenceView, Union{Tuple{Number, Number}, StaticArraysCore.StaticArray{Tuple{2}, &lt;:Number, 1}}, TelecomUtils.ExtraOutput}"><code>get_range</code></a>, <a href="#TelecomUtils.get_pointing-Tuple{ReferenceView, Union{LLA, Tuple{Number, Number, Number}, StaticArraysCore.StaticArray{Tuple{3}, &lt;:Number, 1}}, TelecomUtils.ExtraOutput}"><code>get_pointing</code></a>, <a href="#TelecomUtils.get_lla-Tuple{ReferenceView, Union{Tuple{Number, Number}, StaticArraysCore.StaticArray{Tuple{2}, &lt;:Number, 1}}, TelecomUtils.ExtraOutput}"><code>get_lla</code></a>, <a href="#TelecomUtils.get_ecef-Tuple{ReferenceView, Union{Tuple{Number, Number}, StaticArraysCore.StaticArray{Tuple{2}, &lt;:Number, 1}}, TelecomUtils.ExtraOutput}"><code>get_ecef</code></a>, <a href="#TelecomUtils.get_ecef-Tuple{ReferenceView, Union{Tuple{Number, Number}, StaticArraysCore.StaticArray{Tuple{2}, &lt;:Number, 1}}, TelecomUtils.ExtraOutput}"><code>get_ecef</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/disberd/TelecomUtils.jl/blob/298af29cfbedee573e0fb7f70ddae3f180392cfa/notebooks/refview_struct.jl#L319-L345">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TelecomUtils.change_reference_face!-Tuple{ReferenceView, Any}" href="#TelecomUtils.change_reference_face!-Tuple{ReferenceView, Any}"><code>TelecomUtils.change_reference_face!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">change_reference_face!(rv::ReferenceView, face)</code></pre><p>Modify the reference face that is used to compute the visibilities from object <code>rv</code>. The face can be specified using an instance of <code>TelecomUtils.Faces</code> (not exported), a Symbol or an Int as follows:   </p><ul><li>TelecomUtils.PositiveX <strong>or</strong> :PositiveX <strong>or</strong> 1</li><li>TelecomUtils.PositiveY <strong>or</strong> :PositiveY <strong>or</strong> 2</li><li>TelecomUtils.PositiveZ  <strong>or</strong> :PositiveZ <strong>or</strong> 3</li><li>TelecomUtils.NegativeX <strong>or</strong> :NegativeX <strong>or</strong> -1</li><li>TelecomUtils.NegativeY <strong>or</strong> :NegativeY <strong>or</strong> -2</li><li>TelecomUtils.NegativeZ <strong>or</strong> :NegativeZ <strong>or</strong> -3</li></ul><p>See also <a href="ref"><code>ReferenceView</code></a>, <a href="#TelecomUtils.change_position!-Tuple{ReferenceView, Any, LLA, Any, Any, Any, Any}"><code>change_position!</code></a>, <a href="#TelecomUtils.change_attitude!-Tuple{ReferenceView}"><code>change_attitude!</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/disberd/TelecomUtils.jl/blob/298af29cfbedee573e0fb7f70ddae3f180392cfa/notebooks/refview_struct.jl#L467-L479">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TelecomUtils.compute_sat_position-Tuple{ECEFfromERA, Any, Any}" href="#TelecomUtils.compute_sat_position-Tuple{ECEFfromERA, Any, Any}"><code>TelecomUtils.compute_sat_position</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">compute_sat_position(era2ecef::ECEFfromERA, el, az; h)
compute_sat_position(lla::LLA, el, az; h)
compute_sat_position(ecef::StaticVector{3}, el, az; h)</code></pre><p>Given a <a href="#TelecomUtils.ECEFfromERA"><code>ECEFfromERA</code></a> transformation, a target elevation <code>el</code> and azimuth <code>az</code>, and a reference height <code>h</code> [m] of the satellite from the orbit center, provides the ECEF coordinates of the satellite that is seen with angles <code>el</code> and <code>az</code> from the origin of the <code>era2ecef</code> instance at an orbit altitude of <code>h</code> <strong>(computed from the earth/orbit center, not from the earth surface)</strong>.</p><p>If called with an <code>LLA</code> or ECEF coordinate as the first argument, it automatically constructs the ECEFfromERA instance <code>era2ecef</code> with the provided coordinate as origin.</p><p><strong>Note</strong></p><p>The values <code>el</code> and <code>az</code> are used internally to construct <a href="#TelecomUtils.ERA"><code>ERA</code></a> objects, so are to be given in [rad] or specified in degrees using <code>°</code> from <code>Unitful</code>, which is also exported by TelecomUtils.</p><p>See also: <a href="#TelecomUtils.ERA"><code>ERA</code></a>, <a href="@ref"><code>ECEF</code></a>, <a href="#TelecomUtils.LLA"><code>LLA</code></a>, <a href="#TelecomUtils.ERAfromECEF"><code>ERAfromECEF</code></a>, <a href="#TelecomUtils.ECEFfromERA"><code>ECEFfromERA</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/disberd/TelecomUtils.jl/blob/298af29cfbedee573e0fb7f70ddae3f180392cfa/notebooks/refview_transformations.jl#L969-L981">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TelecomUtils.crs_rotation-Tuple{}" href="#TelecomUtils.crs_rotation-Tuple{}"><code>TelecomUtils.crs_rotation</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">R = crs_rotation(;rot_x=0.0, rot_y=0.0, rot_z=0.0)</code></pre><p>Create the z-y&#39;-x&#39;&#39; <em>intrinsic</em> <a href="https://en.wikipedia.org/wiki/Euler_angles#Tait%E2%80%93Bryan_angles">Tait-Bryan</a> rotation matrix used to transform/rotate a starting CRS to another one. This is used within <a href="#TelecomUtils.ReferenceView"><code>ReferenceView</code></a> to account for satellite attitude or user pointing when defining the final satellite/user centric CRS.</p><p>Taking as example a <code>SatView</code>, the default CRS without any attitude rotation is always the <code>WND</code> one centered on the satellite, with the <code>X</code> axis pointing towards West, <code>Y</code> axis towards north and <code>Z</code> axis towards nadir.</p><p>Let&#39;s call this default CRS as <code>WND</code> and let&#39;s assume to have a satellite in a LEO orbit with an inclination of <code>70</code> degrees. Let&#39;s assume that the satellite is at its ascending node, and that we want to rotate the CRS of the satellite so that the <code>Y</code> axis points in the direction of propagation. To create this new CRS that we will call <code>XYZ</code>, we have to rotate the <code>WND</code> one by <code>20</code> degrees clock-wise around the <code>Z</code> axis of the <code>WND</code> CRS.</p><p>Assuming to have a point <code>xyz</code> in coordinates relative to the <code>XYZ</code> CRS, we can express the same point as <code>wnd</code> relative to the <code>WND</code> CRS with the following equation:</p><pre><code class="nohighlight hljs">wnd = crs_rotation(;rot_z=20°) * xyz</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/disberd/TelecomUtils.jl/blob/298af29cfbedee573e0fb7f70ddae3f180392cfa/notebooks/refview_struct.jl#L292-L306">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TelecomUtils.db2lin-Tuple{Real}" href="#TelecomUtils.db2lin-Tuple{Real}"><code>TelecomUtils.db2lin</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">db2lin(x::Real) -&gt; Any
</code></pre><p>Convert a number from dB to linear</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/disberd/TelecomUtils.jl/blob/298af29cfbedee573e0fb7f70ddae3f180392cfa/notebooks/utils.jl#L212">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TelecomUtils.f2λ-Tuple{Real}" href="#TelecomUtils.f2λ-Tuple{Real}"><code>TelecomUtils.f2λ</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">f2λ(f::Real) -&gt; Any
</code></pre><p>Get the wavelength (in m) starting from the frequency (in Hz)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/disberd/TelecomUtils.jl/blob/298af29cfbedee573e0fb7f70ddae3f180392cfa/notebooks/utils.jl#L220">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TelecomUtils.generate_colors" href="#TelecomUtils.generate_colors"><code>TelecomUtils.generate_colors</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">generate_colors(BeamCenters::AbstractVector,N_Colours::Int=4;lattice_type::Symbol=:triangular)</code></pre><p>Provide a the coloring breakdown for a given set of lattice points.</p><p><strong>Arguments</strong></p><ul><li><code>BeamCenters</code> → Vector of Tuple or StaticVectors expressing the U-V coordinates of each point in the lattice for which the coloring is being computed</li><li><code>N_Colours</code> → Number of colors to divide the lattice in. Defaults to <code>4</code></li></ul><p><strong>keyword Arguments</strong></p><ul><li><code>lattice_type</code> → Symbol that can either be <code>:triangular</code> or <code>:square</code>, idenifying the type of lattice. Defaults to <code>:triangular</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/disberd/TelecomUtils.jl/blob/298af29cfbedee573e0fb7f70ddae3f180392cfa/notebooks/utils.jl#L806-L816">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TelecomUtils.generate_colors-NTuple{4, Any}" href="#TelecomUtils.generate_colors-NTuple{4, Any}"><code>TelecomUtils.generate_colors</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">generate_colors(BeamCenters, colordict, L, F; first_color_idx, first_color_coord) -&gt; Any
</code></pre><p>Provide a the coloring breakdown for a given set of lattice points.</p><p><strong>Arguments</strong></p><ul><li><code>BeamCenters</code> → Array of SVector{2,&lt;:Number} points identifying the beam lattice centers</li><li><code>colordict</code> → Dictionary of the optimal color order for the given coloring scheme, obtained using <a href="#TelecomUtils.get_color_illumination_order-Tuple{Any}"><code>get_color_illumination_order</code></a></li><li><code>L</code> → Beam Lattice generating matrix, function of the beam spacing and lattice type and obtained using <a href="#TelecomUtils.get_L-Tuple{Any}"><code>get_L</code></a></li><li><code>F</code> → Color Lattice generating matrix, function of the number of colors and beam lattice type and obtained using <a href="@ref"><code>generate_F_reuse_matrix</code></a></li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>first_color_idx</code> → Provide the index of the point in BeamCenters that should be associated with color 1.</li><li><code>first_color_coord</code> → Provide the coordinates of the point that should be associated with color 1, if both coord and idx are provided, the idx is ignored. Defaults to the giving color 1 to the point in (0,0).</li></ul><p><strong>Note</strong></p><p>The colors are ordered in such a way that if illuminating the colors in sequential order, the next color is always the one that has the maximum minimum distance with points of the previoulsy illuminated colors (so the one most likely to create lower interference).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/disberd/TelecomUtils.jl/blob/298af29cfbedee573e0fb7f70ddae3f180392cfa/notebooks/utils.jl#L778">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TelecomUtils.generate_hex_lattice-Tuple{Real, Vararg{Any}}" href="#TelecomUtils.generate_hex_lattice-Tuple{Real, Vararg{Any}}"><code>TelecomUtils.generate_hex_lattice</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>generate_hex_lattice(spacing::Real[,f_cond];kwargs...)</code></p><p><strong>Summary</strong></p><p>Generate a hexagonal lattice of points (with equal distance between neighboring points). The hexagonal lattice generated by this function has distance between points on the same column √3 times greater than the distance between points on the same row.</p><p><strong>Arguments</strong></p><ul><li><code>spacing</code> → spacing between points</li></ul><p>See <a href="#TelecomUtils.generate_regular_lattice-Union{Tuple{T}, Tuple{T, T, T}, Tuple{T, T, T, Function}} where T&lt;:Real"><code>generate_regular_lattice</code></a> for a description of <code>f_cond</code> and of  the keyword arguments</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/disberd/TelecomUtils.jl/blob/298af29cfbedee573e0fb7f70ddae3f180392cfa/notebooks/utils.jl#L176-L186">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TelecomUtils.generate_rect_lattice-Tuple{Real, Real, Vararg{Any}}" href="#TelecomUtils.generate_rect_lattice-Tuple{Real, Real, Vararg{Any}}"><code>TelecomUtils.generate_rect_lattice</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">generate_rect_lattice(spacing_x::Real,spacing_y::Real[,f_cond];kwargs...)</code></pre><p><strong>Summary</strong></p><p>Generate a rectangular lattice of points (with different spacing among x and y directions)</p><p><strong>Arguments</strong></p><ul><li><code>spacing_x</code> → spacing between points on the x axis</li><li><code>spacing_y</code> → spacing between points on the y axis</li></ul><p>See <a href="#TelecomUtils.generate_regular_lattice-Union{Tuple{T}, Tuple{T, T, T}, Tuple{T, T, T, Function}} where T&lt;:Real"><code>generate_regular_lattice</code></a> for a description of <code>f_cond</code> and of  the keyword arguments</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/disberd/TelecomUtils.jl/blob/298af29cfbedee573e0fb7f70ddae3f180392cfa/notebooks/utils.jl#L129-L138">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TelecomUtils.generate_regular_lattice-Union{Tuple{T}, Tuple{T, T, T}, Tuple{T, T, T, Function}} where T&lt;:Real" href="#TelecomUtils.generate_regular_lattice-Union{Tuple{T}, Tuple{T, T, T}, Tuple{T, T, T, Function}} where T&lt;:Real"><code>TelecomUtils.generate_regular_lattice</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Generate a regular lattice of points</p><pre><code class="language-julia hljs">generate_regular_lattice(dx::Real, dy::Real, ds::Real) -&gt; Any
generate_regular_lattice(dx::Real, dy::Real, ds::Real, f_cond::Function; x0, y0, M, N) -&gt; Any
</code></pre><p><strong>Arguments</strong></p><ul><li><code>dx</code> → element spacing on the x axis</li><li><code>dy</code> → element spacing on the y axis</li><li><code>ds</code> → displacement along x between rows of elements</li><li><code>f_cond::Function</code> → function of two arguments (<code>f(x,y) = ...</code>) returning <code>true</code> if element at position <code>x,y</code> must be kept and <code>false</code> otherwise</li></ul><p><strong>Keyord Arguments</strong></p><ul><li><code>x0 = 0</code> → x coordinate of the origin of the lattice</li><li><code>y0 = 0</code> → y coordinate of the origin of the lattice</li><li><code>M::Int = 70</code> → Number of elements to generate per row of points before appliying the filtering function <code>f_cond</code></li><li><code>N::Int = M</code> → Number of rows of points to generate before appliying the filtering function <code>f_cond</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/disberd/TelecomUtils.jl/blob/298af29cfbedee573e0fb7f70ddae3f180392cfa/notebooks/utils.jl#L90-L105">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TelecomUtils.generate_square_lattice-Tuple{Real, Vararg{Any}}" href="#TelecomUtils.generate_square_lattice-Tuple{Real, Vararg{Any}}"><code>TelecomUtils.generate_square_lattice</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>generate_square_lattice(spacing::Real[,f_cond];kwargs...)</code></p><p><strong>Summary</strong></p><p>Generate a square lattice of points (with equal spacing among x and y directions)</p><p><strong>Arguments</strong></p><ul><li><code>spacing</code> → spacing between points on both x and y axis</li></ul><p>See <a href="#TelecomUtils.generate_regular_lattice-Union{Tuple{T}, Tuple{T, T, T}, Tuple{T, T, T, Function}} where T&lt;:Real"><code>generate_regular_lattice</code></a> for a description of <code>f_cond</code> and of  the keyword arguments</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/disberd/TelecomUtils.jl/blob/298af29cfbedee573e0fb7f70ddae3f180392cfa/notebooks/utils.jl#L150-L158">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TelecomUtils.geod_inverse-Tuple{Proj4.geod_geodesic, AbstractVector{Float64}, AbstractVector{Float64}}" href="#TelecomUtils.geod_inverse-Tuple{Proj4.geod_geodesic, AbstractVector{Float64}, AbstractVector{Float64}}"><code>TelecomUtils.geod_inverse</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">geod_inverse(geod::Proj4.geod_geodesic, lonlat1::AbstractVector{Cdouble}, lonlat2::AbstractVector{Cdouble})
geod_inverse(geod::Proj4.geod_geodesic, lla1::LLA, lla2::LLA)
geod_inverse(em::EarthModel, lla1::LLA, lla2::LLA)</code></pre><p>Solve the inverse geodesic problem.</p><p><strong>Args</strong></p><ul><li><code>g</code>       → the geod_geodesic object specifying the ellipsoid.</li><li><code>lonlat1</code> → point 1 (degrees), where lat ∈ [-90, 90], lon ∈ [-540, 540) </li><li><code>lonlat2</code> → point 2 (degrees), where lat ∈ [-90, 90], lon ∈ [-540, 540) </li></ul><p><strong>Outputs</strong></p><ul><li><code>dist</code> → distance between point 1 and point 2 (meters).</li><li><code>azi1</code> → azimuth at point 1 (degrees) ∈ [-180, 180)</li><li><code>azi2</code> → (forward) azimuth at point 2 (degrees) ∈ [-180, 180)</li></ul><p><strong>Remarks</strong></p><p>If either point is at a pole, the azimuth is defined by keeping the longitude fixed, writing lat = 90 +/- eps, and taking the limit as eps -&gt; 0+.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/disberd/TelecomUtils.jl/blob/298af29cfbedee573e0fb7f70ddae3f180392cfa/notebooks/refview_basics.jl#L537-L559">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TelecomUtils.get_L-Tuple{Any}" href="#TelecomUtils.get_L-Tuple{Any}"><code>TelecomUtils.get_L</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_L(spacing; lattice_type) -&gt; Any
</code></pre><p>Get the lattice generating matrix as a function of the <code>lattice_type</code> and of the lattice <code>spacing</code>.</p><p><code>lattice_type</code> has to be either <code>:triangular</code> or <code>:square</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/disberd/TelecomUtils.jl/blob/298af29cfbedee573e0fb7f70ddae3f180392cfa/notebooks/utils.jl#L747">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TelecomUtils.get_angular_distance-Tuple{Any, Any}" href="#TelecomUtils.get_angular_distance-Tuple{Any, Any}"><code>TelecomUtils.get_angular_distance</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_angular_distance(p₁, p₂; input_type=:UV, output_type=:thetaphi)</code></pre><p>Compute the angular distance between the target pointing direction <code>p₂</code> and the starting pointing direction <code>p₁</code>. The two target pointings can be intepreted as either UV or ThetaPhi coordinates depending on the value of the <code>input_type</code> kwarg.</p><p>The output is a scalar that depending on the value of the <code>output_type</code> kwarg represents either the distance in UV, or the angular distance (Δθ) between <code>p₂</code> and <code>p₁</code>.</p><p>For both <code>input_type</code> and <code>output_type</code>, the following Symbols are supported:</p><ul><li><code>:thetaphi</code>, <code>:ThetaPhi</code> and <code>:θφ</code> can be used to represent pointing in ThetaPhi</li><li><code>:UV</code> and <code>:uv</code> can be used to represent pointing in UV</li></ul><p><strong>Note</strong></p><p>All input angles are intepreted as radians unless specified as a Quantity in degrees using <code>°</code> from Unitful.</p><p>The output angles (when <code>output_type</code> is ThetaPhi) are also expressed in radians</p><p>This function is similar to <a href="#TelecomUtils.get_angular_offset-Tuple{Any, Any}"><code>get_angular_offset</code></a> but has a slightly faster implementation in case only the distance is required, rather than the full 2D offset. The following code should evaluate to true</p><pre><code class="language-julia hljs">uv1 = (.3,.4)
uv2 = (-.2,.5)
offset = get_angular_offset(uv1, uv2; input_type = :uv, output_type = :thetaphi)
Δθ = get_angular_distance(uv1, uv2; input_type = :uv, output_type = :thetaphi)
offset[1] ≈ Δθ</code></pre><p>See also: <a href="#TelecomUtils.add_angular_offset-Tuple{Any, Any}"><code>add_angular_offset</code></a>, <a href="#TelecomUtils.get_angular_offset-Tuple{Any, Any}"><code>get_angular_offset</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/disberd/TelecomUtils.jl/blob/298af29cfbedee573e0fb7f70ddae3f180392cfa/notebooks/refview_transformations.jl#L750-L777">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TelecomUtils.get_angular_offset-Tuple{Any, Any}" href="#TelecomUtils.get_angular_offset-Tuple{Any, Any}"><code>TelecomUtils.get_angular_offset</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_angular_offset(p₁, p₂; input_type=:UV, output_type=:thetaphi)</code></pre><p>Compute the angular offset required to reach the target pointing direction <code>p₂</code> from starting pointing direction <code>p₁</code>. The two target pointings can be intepreted as either UV or ThetaPhi coordinates depending on the value of the <code>input_type</code> kwarg.</p><p>The output is provided as an SVector{2,Float64} and depending on the value of the <code>output_type</code> kwarg it represents either the Δu, Δv offset in UV, or the angular offset (θ and φ) required to reach <code>p₂</code> from <code>p₁</code>.</p><p>For both <code>input_type</code> and <code>output_type</code>, the following Symbols are supported:</p><ul><li><code>:thetaphi</code>, <code>:ThetaPhi</code> and <code>:θφ</code> can be used to represent pointing in ThetaPhi</li><li><code>:UV</code> and <code>:uv</code> can be used to represent pointing in UV</li></ul><p><strong>Note</strong></p><p>All input angles are intepreted as radians unless specified as a Quantity in degrees using <code>°</code> from Unitful.</p><p>The output angles (when <code>output_type</code> is ThetaPhi) are also expressed in radians</p><p>This function performs the inverse operation of <a href="#TelecomUtils.add_angular_offset-Tuple{Any, Any}"><code>add_angular_offset</code></a> so the following code should return true</p><pre><code class="language-julia hljs">uv1 = (.3,.4)
uv2 = (-.2,.5)
offset = get_angular_offset(uv1, uv2; input_type = :uv, output_type = :thetaphi)
p = add_angular_offset(uv1, offset; input_type = :uv, output_type = :uv)
all(p .≈ uv2)</code></pre><p>Check out <a href="#TelecomUtils.get_angular_distance-Tuple{Any, Any}"><code>get_angular_distance</code></a> for a slightly faster implementation in case you only require the angular distance rather than the 2D offset.</p><p>See also: <a href="#TelecomUtils.add_angular_offset-Tuple{Any, Any}"><code>add_angular_offset</code></a>, <a href="#TelecomUtils.get_angular_distance-Tuple{Any, Any}"><code>get_angular_distance</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/disberd/TelecomUtils.jl/blob/298af29cfbedee573e0fb7f70ddae3f180392cfa/notebooks/refview_transformations.jl#L1255-L1282">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TelecomUtils.get_color_illumination_order-Tuple{Any}" href="#TelecomUtils.get_color_illumination_order-Tuple{Any}"><code>TelecomUtils.get_color_illumination_order</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_color_illumination_order(N; lattice_type) -&gt; Tuple{Dictionaries.Dictionary{StaticArraysCore.SVector{2, Int64}, Int64}, StaticArraysCore.SMatrix{2, 2, Int64, 4}}
</code></pre><p>Get the illumination order to achieve maximum possible distance between already illuminated colors and next illuminated color.</p><p>Returns a <code>Dictionary</code> associating each unique color vector obtained from <a href="@ref"><code>get_deterministic_color_order</code></a> to the ordering color. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/disberd/TelecomUtils.jl/blob/298af29cfbedee573e0fb7f70ddae3f180392cfa/notebooks/utils.jl#L657">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TelecomUtils.get_distance_on_earth-Tuple{LLA, LLA, TelecomUtils.ExtraOutput}" href="#TelecomUtils.get_distance_on_earth-Tuple{LLA, LLA, TelecomUtils.ExtraOutput}"><code>TelecomUtils.get_distance_on_earth</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_distance_on_earth(sv::SatView, p1::Point2D, p2::Point2D[, ::ExtraOutput]; pointing_type::Symbol=:uv, face = sv.face, R)
get_distance_on_earth(p1::LLA, p2::LLA[, ::ExtraOutput]; em = EarthModel())
get_distance_on_earth(p1::UserView, p2::UserView)</code></pre><p>Computes the distance [m] between the points on the earth surface (<code>lla1</code> and <code>lla2</code>) using the reference earth model used by <code>sv</code>.</p><p>If the points are not provided as LLA instances, but as angular directions (<code>p1</code> and <code>p2</code>), <code>lla1</code> and <code>lla2</code> as first computed from <code>p1</code> and <code>p2</code> using the SatView object <code>sv</code> as reference.</p><p>When called with angular directions, the optional argument <code>kind</code> is used to select whether the pointing is expressed in ThetaPhi (<code>kind ∈ (:ThetaPhi, :thetaphi, :θφ)</code>) [rad] or UV coordinates.</p><p>If an instance of <code>ExtraOutput</code> is provided as 4th argument, the function also returns the (forward) azimuth angle between <code>lla1</code> and <code>lla2</code> (2nd output, [deg]) and the azimuth angle between <code>lla2</code> and <code>lla1</code> (third output, [deg])</p><p>See also: <a href="@ref"><code>SatView</code></a>, <a href="#TelecomUtils.get_range-Tuple{ReferenceView, Union{Tuple{Number, Number}, StaticArraysCore.StaticArray{Tuple{2}, &lt;:Number, 1}}, TelecomUtils.ExtraOutput}"><code>get_range</code></a>, <a href="#TelecomUtils.get_pointing-Tuple{ReferenceView, Union{LLA, Tuple{Number, Number, Number}, StaticArraysCore.StaticArray{Tuple{3}, &lt;:Number, 1}}, TelecomUtils.ExtraOutput}"><code>get_pointing</code></a>, <a href="#TelecomUtils.get_lla-Tuple{ReferenceView, Union{Tuple{Number, Number}, StaticArraysCore.StaticArray{Tuple{2}, &lt;:Number, 1}}, TelecomUtils.ExtraOutput}"><code>get_lla</code></a>, <a href="#TelecomUtils.get_ecef-Tuple{ReferenceView, Union{Tuple{Number, Number}, StaticArraysCore.StaticArray{Tuple{2}, &lt;:Number, 1}}, TelecomUtils.ExtraOutput}"><code>get_ecef</code></a>, <a href="#TelecomUtils.geod_inverse-Tuple{Proj4.geod_geodesic, AbstractVector{Float64}, AbstractVector{Float64}}"><code>geod_inverse</code></a>, <a href="#TelecomUtils.get_nadir_beam_diameter-Tuple{Any, Any}"><code>get_nadir_beam_diameter</code></a>, <a href="@ref"><code>ExtraOutput</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/disberd/TelecomUtils.jl/blob/298af29cfbedee573e0fb7f70ddae3f180392cfa/notebooks/refview_struct.jl#L1465-L1478">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TelecomUtils.get_ecef-Tuple{ReferenceView, Union{Tuple{Number, Number}, StaticArraysCore.StaticArray{Tuple{2}, &lt;:Number, 1}}, TelecomUtils.ExtraOutput}" href="#TelecomUtils.get_ecef-Tuple{ReferenceView, Union{Tuple{Number, Number}, StaticArraysCore.StaticArray{Tuple{2}, &lt;:Number, 1}}, TelecomUtils.ExtraOutput}"><code>TelecomUtils.get_ecef</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_ecef(rv::ReferenceView, pointing::Point2D[, ::ExtraOutput]; pointing_type::Symbol=:uv, h = 0.0, face = rv.face, R = nothing)</code></pre><p>Computes the ECEF coordinates of the point that is seen by <code>rv</code> in the direction specified by <code>pointing</code> and is located at a target altitude <code>h</code> [m] above the earth&#39;s surface.</p><p>If a valid point can not be found because either earth is blocking the view or no point at altitude <code>h</code> can be seen from the provided pointing direction in the <code>rv</code> local CRS (also accounting for desired face), the function returns a SVector{3, Float64} filled win NaNs.</p><p><code>pointing_type</code> is used to select whether the output is returned in UV or ThetaPhi [rad] coordinates. The following symbols are supported for this kwarg:</p><ul><li><code>:thetaphi</code>, <code>:ThetaPhi</code> and <code>:θφ</code> can be used to represent pointing in ThetaPhi [rad]</li><li><code>:UV</code> and <code>:uv</code> can be used to represent pointing in UV</li></ul><p>When called with an instance of <code>TelecomUtils.ExtraOutput</code> as last argument, the function also returns the coordinated of the identified point in the local CRS of <code>rv</code>.</p><p>For details on how to modify the reference pointing direction using the kwargs <code>face</code> and <code>R</code> look at the documentation of <a href="#TelecomUtils.get_range-Tuple{ReferenceView, Union{Tuple{Number, Number}, StaticArraysCore.StaticArray{Tuple{2}, &lt;:Number, 1}}, TelecomUtils.ExtraOutput}"><code>get_range</code></a> </p><p>See also: <a href="#TelecomUtils.ReferenceView"><code>ReferenceView</code></a>, <a href="#TelecomUtils.get_range-Tuple{ReferenceView, Union{Tuple{Number, Number}, StaticArraysCore.StaticArray{Tuple{2}, &lt;:Number, 1}}, TelecomUtils.ExtraOutput}"><code>get_range</code></a>, <a href="#TelecomUtils.get_pointing-Tuple{ReferenceView, Union{LLA, Tuple{Number, Number, Number}, StaticArraysCore.StaticArray{Tuple{3}, &lt;:Number, 1}}, TelecomUtils.ExtraOutput}"><code>get_pointing</code></a>, <a href="#TelecomUtils.get_lla-Tuple{ReferenceView, Union{Tuple{Number, Number}, StaticArraysCore.StaticArray{Tuple{2}, &lt;:Number, 1}}, TelecomUtils.ExtraOutput}"><code>get_lla</code></a>, <a href="#TelecomUtils.get_era-Tuple{UserView, Union{LLA, Tuple{Number, Number, Number}, StaticArraysCore.StaticArray{Tuple{3}, &lt;:Number, 1}, ReferenceView}}"><code>get_era</code></a>, <a href="#TelecomUtils.get_distance_on_earth-Tuple{LLA, LLA, TelecomUtils.ExtraOutput}"><code>get_distance_on_earth</code></a>, <a href="#TelecomUtils.get_visibility-Tuple{ReferenceView, Union{LLA, Tuple{Number, Number, Number}, StaticArraysCore.StaticArray{Tuple{3}, &lt;:Number, 1}}, TelecomUtils.ExtraOutput}"><code>get_visibility</code></a>, <a href="#TelecomUtils.get_mutual_visibility-Tuple{ReferenceView, ReferenceView, TelecomUtils.ExtraOutput}"><code>get_mutual_visibility</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/disberd/TelecomUtils.jl/blob/298af29cfbedee573e0fb7f70ddae3f180392cfa/notebooks/refview_struct.jl#L1107-L1134">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TelecomUtils.get_era-Tuple{UserView, Union{LLA, Tuple{Number, Number, Number}, StaticArraysCore.StaticArray{Tuple{3}, &lt;:Number, 1}, ReferenceView}}" href="#TelecomUtils.get_era-Tuple{UserView, Union{LLA, Tuple{Number, Number, Number}, StaticArraysCore.StaticArray{Tuple{3}, &lt;:Number, 1}, ReferenceView}}"><code>TelecomUtils.get_era</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_era(uv::UserView, target::Union{LLA, Point3D, ReferenceView}[, ::ExtraOutput]; face = rv.face, R = nothing)</code></pre><p>Computes the ERA coordinates of the provided <code>target</code> as seen from the <code>UserView</code> <code>uv</code>. <code>target</code> can be given either as <code>LLA</code>/<code>ECEF</code> coordinates or directly as another <code>ReferenceView</code></p><p>For details on how to modify the reference pointing direction using the kwargs <code>face</code> and <code>R</code> look at the documentation of <a href="#TelecomUtils.get_range-Tuple{ReferenceView, Union{Tuple{Number, Number}, StaticArraysCore.StaticArray{Tuple{2}, &lt;:Number, 1}}, TelecomUtils.ExtraOutput}"><code>get_range</code></a> </p><p>See also: <a href="#TelecomUtils.ReferenceView"><code>ReferenceView</code></a>, <a href="#TelecomUtils.get_range-Tuple{ReferenceView, Union{Tuple{Number, Number}, StaticArraysCore.StaticArray{Tuple{2}, &lt;:Number, 1}}, TelecomUtils.ExtraOutput}"><code>get_range</code></a>, <a href="#TelecomUtils.get_pointing-Tuple{ReferenceView, Union{LLA, Tuple{Number, Number, Number}, StaticArraysCore.StaticArray{Tuple{3}, &lt;:Number, 1}}, TelecomUtils.ExtraOutput}"><code>get_pointing</code></a>, <a href="#TelecomUtils.get_lla-Tuple{ReferenceView, Union{Tuple{Number, Number}, StaticArraysCore.StaticArray{Tuple{2}, &lt;:Number, 1}}, TelecomUtils.ExtraOutput}"><code>get_lla</code></a>, <a href="#TelecomUtils.get_ecef-Tuple{ReferenceView, Union{Tuple{Number, Number}, StaticArraysCore.StaticArray{Tuple{2}, &lt;:Number, 1}}, TelecomUtils.ExtraOutput}"><code>get_ecef</code></a>, <a href="#TelecomUtils.get_distance_on_earth-Tuple{LLA, LLA, TelecomUtils.ExtraOutput}"><code>get_distance_on_earth</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/disberd/TelecomUtils.jl/blob/298af29cfbedee573e0fb7f70ddae3f180392cfa/notebooks/refview_struct.jl#L1297-L1306">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TelecomUtils.get_lla-Tuple{ReferenceView, Union{Tuple{Number, Number}, StaticArraysCore.StaticArray{Tuple{2}, &lt;:Number, 1}}, TelecomUtils.ExtraOutput}" href="#TelecomUtils.get_lla-Tuple{ReferenceView, Union{Tuple{Number, Number}, StaticArraysCore.StaticArray{Tuple{2}, &lt;:Number, 1}}, TelecomUtils.ExtraOutput}"><code>TelecomUtils.get_lla</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_lla(rv::ReferenceView, pointing::Point2D[, ::ExtraOutput]; pointing_type::Symbol=:uv, h = 0.0, face = rv.face, R = nothing)</code></pre><p>Computes the LLA coordinates of the point that is seen by <code>rv</code> in the direction specified by <code>pointing</code> and is located at a target altitude <code>h</code> [m] above the earth&#39;s surface.</p><p>If a valid point can not be found because either earth is blocking the view or no point at altitude <code>h</code> can be seen from the provided pointing direction in the <code>rv</code> local CRS (also accounting for desired face), the function returns a SVector{3, Float64} filled win NaNs.</p><p><code>pointing_type</code> is used to select whether the output is returned in UV or ThetaPhi [rad] coordinates. The following symbols are supported for this kwarg:</p><ul><li><code>:thetaphi</code>, <code>:ThetaPhi</code> and <code>:θφ</code> can be used to represent pointing in ThetaPhi [rad]</li><li><code>:UV</code> and <code>:uv</code> can be used to represent pointing in UV</li></ul><p>When called with an instance of <code>TelecomUtils.ExtraOutput</code> as last argument, the function also returns the coordinated of the identified point in the local CRS of <code>rv</code>.</p><p>For details on how to modify the reference pointing direction using the kwargs <code>face</code> and <code>R</code> look at the documentation of <a href="#TelecomUtils.get_range-Tuple{ReferenceView, Union{Tuple{Number, Number}, StaticArraysCore.StaticArray{Tuple{2}, &lt;:Number, 1}}, TelecomUtils.ExtraOutput}"><code>get_range</code></a> </p><p>See also: <a href="#TelecomUtils.ReferenceView"><code>ReferenceView</code></a>, <a href="#TelecomUtils.get_range-Tuple{ReferenceView, Union{Tuple{Number, Number}, StaticArraysCore.StaticArray{Tuple{2}, &lt;:Number, 1}}, TelecomUtils.ExtraOutput}"><code>get_range</code></a>, <a href="#TelecomUtils.get_pointing-Tuple{ReferenceView, Union{LLA, Tuple{Number, Number, Number}, StaticArraysCore.StaticArray{Tuple{3}, &lt;:Number, 1}}, TelecomUtils.ExtraOutput}"><code>get_pointing</code></a>, <a href="#TelecomUtils.get_lla-Tuple{ReferenceView, Union{Tuple{Number, Number}, StaticArraysCore.StaticArray{Tuple{2}, &lt;:Number, 1}}, TelecomUtils.ExtraOutput}"><code>get_lla</code></a>, <a href="#TelecomUtils.get_ecef-Tuple{ReferenceView, Union{Tuple{Number, Number}, StaticArraysCore.StaticArray{Tuple{2}, &lt;:Number, 1}}, TelecomUtils.ExtraOutput}"><code>get_ecef</code></a>, <a href="#TelecomUtils.get_era-Tuple{UserView, Union{LLA, Tuple{Number, Number, Number}, StaticArraysCore.StaticArray{Tuple{3}, &lt;:Number, 1}, ReferenceView}}"><code>get_era</code></a>, <a href="#TelecomUtils.get_distance_on_earth-Tuple{LLA, LLA, TelecomUtils.ExtraOutput}"><code>get_distance_on_earth</code></a>, <a href="#TelecomUtils.get_visibility-Tuple{ReferenceView, Union{LLA, Tuple{Number, Number, Number}, StaticArraysCore.StaticArray{Tuple{3}, &lt;:Number, 1}}, TelecomUtils.ExtraOutput}"><code>get_visibility</code></a>, <a href="#TelecomUtils.get_mutual_visibility-Tuple{ReferenceView, ReferenceView, TelecomUtils.ExtraOutput}"><code>get_mutual_visibility</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/disberd/TelecomUtils.jl/blob/298af29cfbedee573e0fb7f70ddae3f180392cfa/notebooks/refview_struct.jl#L1169-L1196">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TelecomUtils.get_mutual_pointing-Tuple{ReferenceView, ReferenceView, TelecomUtils.ExtraOutput}" href="#TelecomUtils.get_mutual_pointing-Tuple{ReferenceView, ReferenceView, TelecomUtils.ExtraOutput}"><code>TelecomUtils.get_mutual_pointing</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">p₁, p₂ = get_mutual_pointing(rv1::ReferenceView, rv2::ReferenceView[, ::ExtraOutput]; pointing_type::Symbol=:uv, faces = (rv1.face, rv2.face), Rs=(nothing, nothing), short_circuit = true)</code></pre><p>Provide the 2-D angular pointing in both directions between <code>rv1</code> and <code>rv2</code>:</p><ul><li><code>p₁</code> is the pointing of <code>rv2</code> with respect to <code>rv1</code></li><li><code>p₂</code> is the pointing of <code>rv1</code> with respect to <code>rv2</code></li></ul><p><code>pointing_type</code> is used to select whether the outputs are returned in UV or ThetaPhi [rad] coordinates. The following symbols are supported for this kwarg:</p><ul><li><code>:thetaphi</code>, <code>:ThetaPhi</code> and <code>:θφ</code> can be used to represent pointing in ThetaPhi [rad]</li><li><code>:UV</code> and <code>:uv</code> can be used to represent pointing in UV</li></ul><p>When called with an instance of <code>TelecomUtils.ExtraOutput</code> as last argument, the function also returns the coordinated of the identified point in the local CRS of <code>rv1</code> (or <code>rv2</code>). In this case:</p><ul><li><code>p₁</code> is a tuple containing the pointing as first argument, the local CRS coordinates of <code>rv2</code> with respect to <code>rv1</code> as second argument and a NamedTuple with earth blockage data as third argument.</li><li><code>p₂</code> is a tuple containing the pointing as first argument, the local CRS coordinates of <code>rv1</code> with respect to <code>rv2</code> as second argument and a NamedTuple with earth blockage data as third argument.</li></ul><p><code>faces</code> and <code>Rs</code> are tuples containing the values of <code>face</code> and <code>R</code> for the two ReferenceView objects. <code>faces[1]</code> is used as reference face for <code>rv1</code> while <code>faces[2]</code> is used for <code>rv2</code>. Similarly for <code>Rs</code>.</p><p>The <code>short_circuit</code> kwarg defaults to true and permits to return early from the function to save time.  When <code>short_circuit == true</code>, if the fwd pointing is false because of earth blockage, the function will directly return without computing the pointing on the return direction.</p><p>For details on how to modify the reference pointing direction using <code>face</code> and <code>R</code> look at the documentation of <a href="#TelecomUtils.get_range-Tuple{ReferenceView, Union{Tuple{Number, Number}, StaticArraysCore.StaticArray{Tuple{2}, &lt;:Number, 1}}, TelecomUtils.ExtraOutput}"><code>get_range</code></a> </p><p>See also: <a href="#TelecomUtils.ReferenceView"><code>ReferenceView</code></a>, <a href="#TelecomUtils.get_range-Tuple{ReferenceView, Union{Tuple{Number, Number}, StaticArraysCore.StaticArray{Tuple{2}, &lt;:Number, 1}}, TelecomUtils.ExtraOutput}"><code>get_range</code></a>, <a href="#TelecomUtils.get_pointing-Tuple{ReferenceView, Union{LLA, Tuple{Number, Number, Number}, StaticArraysCore.StaticArray{Tuple{3}, &lt;:Number, 1}}, TelecomUtils.ExtraOutput}"><code>get_pointing</code></a>, <a href="#TelecomUtils.get_lla-Tuple{ReferenceView, Union{Tuple{Number, Number}, StaticArraysCore.StaticArray{Tuple{2}, &lt;:Number, 1}}, TelecomUtils.ExtraOutput}"><code>get_lla</code></a>, <a href="#TelecomUtils.get_ecef-Tuple{ReferenceView, Union{Tuple{Number, Number}, StaticArraysCore.StaticArray{Tuple{2}, &lt;:Number, 1}}, TelecomUtils.ExtraOutput}"><code>get_ecef</code></a>, <a href="#TelecomUtils.get_distance_on_earth-Tuple{LLA, LLA, TelecomUtils.ExtraOutput}"><code>get_distance_on_earth</code></a>, <a href="#TelecomUtils.get_visibility-Tuple{ReferenceView, Union{LLA, Tuple{Number, Number, Number}, StaticArraysCore.StaticArray{Tuple{3}, &lt;:Number, 1}}, TelecomUtils.ExtraOutput}"><code>get_visibility</code></a>, <a href="#TelecomUtils.get_mutual_visibility-Tuple{ReferenceView, ReferenceView, TelecomUtils.ExtraOutput}"><code>get_mutual_visibility</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/disberd/TelecomUtils.jl/blob/298af29cfbedee573e0fb7f70ddae3f180392cfa/notebooks/refview_struct.jl#L791-L824">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TelecomUtils.get_mutual_visibility-Tuple{ReferenceView, ReferenceView, TelecomUtils.ExtraOutput}" href="#TelecomUtils.get_mutual_visibility-Tuple{ReferenceView, ReferenceView, TelecomUtils.ExtraOutput}"><code>TelecomUtils.get_mutual_visibility</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_mutual_visibility(rv1::ReferenceView, rv2::ReferenceView[, ::ExtraOutput]; boresights = (rv1.face, rv2.face), fov = (90°, 90°), short_circuit = true)</code></pre><p>Similar to <a href="#TelecomUtils.get_visibility-Tuple{ReferenceView, Union{LLA, Tuple{Number, Number, Number}, StaticArraysCore.StaticArray{Tuple{3}, &lt;:Number, 1}}, TelecomUtils.ExtraOutput}"><code>get_visibility</code></a>, returns <code>true</code> if <code>rv1</code> and <code>rv2</code> can see each other, assuming their antenna boresight directions to be specified by <code>boresights</code> and their maximum Field of View from the boresight to be specified by <code>fovs</code>.</p><p><code>boresights</code> and <code>fovs</code> are tuples containing the values of boresight and fov for the two ReferenceView objects. <code>boresights[1]</code> is used as reference boresight for <code>rv1</code> while <code>boresights[2]</code> is used for <code>rv2</code>. Similarly for <code>fovs</code>.</p><p>The <code>short_circuit</code> kwarg defaults to true and permits to return early from the function to save time.  When <code>short_circuit == true</code>, if the fwd visibility is false, the function will directly return without computing the visibility angle on the return direction.</p><p>Each <code>boresight</code> value inside the <code>boresights</code> kwarg can be specified either as a <code>face</code> (compatible with the input types specified in <a href="#TelecomUtils.change_reference_face!-Tuple{ReferenceView, Any}"><code>change_reference_face!</code></a>) or as a 3D pointing vector using either 3 elements Tuple, Vector or SVector. If a 3D vector is provided, the function normalizes to unitary norm automatically.</p><p>Each <code>fov</code> value inside the <code>fovs</code> kwarg must be specified as an angle in radians if provided as a simple Number. To provide a fov in degress, directly use ° from Unitful re-exported by TelecomUtils.</p><p>When called with an instance of <code>TelecomUtils.ExtraOutput</code> as last argument, the function also returns a Tuple containing the full outputs (as if called with ExtraOutput) of <a href="#TelecomUtils.get_visibility-Tuple{ReferenceView, Union{LLA, Tuple{Number, Number, Number}, StaticArraysCore.StaticArray{Tuple{3}, &lt;:Number, 1}}, TelecomUtils.ExtraOutput}"><code>get_visibility</code></a> for each direction (<code>rv1</code> to <code>rv2</code> and vice-versa).</p><p>See also: <a href="#TelecomUtils.get_pointing-Tuple{ReferenceView, Union{LLA, Tuple{Number, Number, Number}, StaticArraysCore.StaticArray{Tuple{3}, &lt;:Number, 1}}, TelecomUtils.ExtraOutput}"><code>get_pointing</code></a>, <a href="#TelecomUtils.get_mutual_pointing-Tuple{ReferenceView, ReferenceView, TelecomUtils.ExtraOutput}"><code>get_mutual_pointing</code></a>, <a href="#TelecomUtils.ReferenceView"><code>ReferenceView</code></a>, <a href="#TelecomUtils.get_range-Tuple{ReferenceView, Union{Tuple{Number, Number}, StaticArraysCore.StaticArray{Tuple{2}, &lt;:Number, 1}}, TelecomUtils.ExtraOutput}"><code>get_range</code></a>, <a href="#TelecomUtils.get_pointing-Tuple{ReferenceView, Union{LLA, Tuple{Number, Number, Number}, StaticArraysCore.StaticArray{Tuple{3}, &lt;:Number, 1}}, TelecomUtils.ExtraOutput}"><code>get_pointing</code></a>, <a href="#TelecomUtils.get_lla-Tuple{ReferenceView, Union{Tuple{Number, Number}, StaticArraysCore.StaticArray{Tuple{2}, &lt;:Number, 1}}, TelecomUtils.ExtraOutput}"><code>get_lla</code></a>, <a href="#TelecomUtils.get_ecef-Tuple{ReferenceView, Union{Tuple{Number, Number}, StaticArraysCore.StaticArray{Tuple{2}, &lt;:Number, 1}}, TelecomUtils.ExtraOutput}"><code>get_ecef</code></a>, <a href="#TelecomUtils.get_distance_on_earth-Tuple{LLA, LLA, TelecomUtils.ExtraOutput}"><code>get_distance_on_earth</code></a>, <a href="#TelecomUtils.get_visibility-Tuple{ReferenceView, Union{LLA, Tuple{Number, Number, Number}, StaticArraysCore.StaticArray{Tuple{3}, &lt;:Number, 1}}, TelecomUtils.ExtraOutput}"><code>get_visibility</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/disberd/TelecomUtils.jl/blob/298af29cfbedee573e0fb7f70ddae3f180392cfa/notebooks/refview_struct.jl#L1015-L1049">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TelecomUtils.get_nadir_beam_diameter-Tuple{Any, Any}" href="#TelecomUtils.get_nadir_beam_diameter-Tuple{Any, Any}"><code>TelecomUtils.get_nadir_beam_diameter</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_nadir_beam_diameter(sv, scan_3db)
</code></pre><p>Computes the diameter [m] on earth of a beam pointed at nadir from the satellite position identified by <code>sv</code> and assuming a 3db beamwidth identified by the scan angle <code>scan_3db</code> [deg] at which the beam pattern is 3dB below the peak.</p><p>The computation computes the diameter along the <code>U</code> direction and takes into account the reference ellipsoid of <code>sv</code>, so the resulting diameter is dependent on the satellite lat/lon position</p><p>See also: <a href="@ref"><code>SatView</code></a>, <a href="#TelecomUtils.get_range-Tuple{ReferenceView, Union{Tuple{Number, Number}, StaticArraysCore.StaticArray{Tuple{2}, &lt;:Number, 1}}, TelecomUtils.ExtraOutput}"><code>get_range</code></a>, <a href="#TelecomUtils.get_pointing-Tuple{ReferenceView, Union{LLA, Tuple{Number, Number, Number}, StaticArraysCore.StaticArray{Tuple{3}, &lt;:Number, 1}}, TelecomUtils.ExtraOutput}"><code>get_pointing</code></a>, <a href="#TelecomUtils.get_lla-Tuple{ReferenceView, Union{Tuple{Number, Number}, StaticArraysCore.StaticArray{Tuple{2}, &lt;:Number, 1}}, TelecomUtils.ExtraOutput}"><code>get_lla</code></a>, <a href="#TelecomUtils.get_ecef-Tuple{ReferenceView, Union{Tuple{Number, Number}, StaticArraysCore.StaticArray{Tuple{2}, &lt;:Number, 1}}, TelecomUtils.ExtraOutput}"><code>get_ecef</code></a>, <a href="#TelecomUtils.geod_inverse-Tuple{Proj4.geod_geodesic, AbstractVector{Float64}, AbstractVector{Float64}}"><code>geod_inverse</code></a>, <a href="#TelecomUtils.get_distance_on_earth-Tuple{LLA, LLA, TelecomUtils.ExtraOutput}"><code>get_distance_on_earth</code></a>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/disberd/TelecomUtils.jl/blob/298af29cfbedee573e0fb7f70ddae3f180392cfa/notebooks/refview_struct.jl#L1525">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TelecomUtils.get_pointing-Tuple{ReferenceView, Union{LLA, Tuple{Number, Number, Number}, StaticArraysCore.StaticArray{Tuple{3}, &lt;:Number, 1}}, TelecomUtils.ExtraOutput}" href="#TelecomUtils.get_pointing-Tuple{ReferenceView, Union{LLA, Tuple{Number, Number, Number}, StaticArraysCore.StaticArray{Tuple{3}, &lt;:Number, 1}}, TelecomUtils.ExtraOutput}"><code>TelecomUtils.get_pointing</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_pointing(rv::ReferenceView, target::Union{LLA, Point3D, ReferenceView}[, ::ExtraOutput]; pointing_type::Symbol=:uv, face = rv.face, R=nothing)</code></pre><p>Provide the 2-D angular pointing at which the target point (specified as LLA, ECEF or as another <code>ReferenceView</code>) is seen from the ReferenceView object <code>rv</code>.</p><p><code>pointing_type</code> is used to select whether the output is returned in UV or ThetaPhi [rad] coordinates. The following symbols are supported for this kwarg:</p><ul><li><code>:thetaphi</code>, <code>:ThetaPhi</code> and <code>:θφ</code> can be used to represent pointing in ThetaPhi [rad]</li><li><code>:UV</code> and <code>:uv</code> can be used to represent pointing in UV</li></ul><p>When called with an instance of <code>TelecomUtils.ExtraOutput</code> as last argument, the function also returns the coordinated of the identified point in the local CRS of <code>rv</code> as second output, and a NamedTuple containing information on the earth blockage status as third argument.</p><p>For details on how to modify the reference pointing direction using the kwargs <code>face</code> and <code>R</code> look at the documentation of <a href="#TelecomUtils.get_range-Tuple{ReferenceView, Union{Tuple{Number, Number}, StaticArraysCore.StaticArray{Tuple{2}, &lt;:Number, 1}}, TelecomUtils.ExtraOutput}"><code>get_range</code></a> </p><p>See also: <a href="#TelecomUtils.get_mutual_pointing-Tuple{ReferenceView, ReferenceView, TelecomUtils.ExtraOutput}"><code>get_mutual_pointing</code></a>, <a href="#TelecomUtils.ReferenceView"><code>ReferenceView</code></a>, <a href="#TelecomUtils.get_range-Tuple{ReferenceView, Union{Tuple{Number, Number}, StaticArraysCore.StaticArray{Tuple{2}, &lt;:Number, 1}}, TelecomUtils.ExtraOutput}"><code>get_range</code></a>, <a href="#TelecomUtils.get_pointing-Tuple{ReferenceView, Union{LLA, Tuple{Number, Number, Number}, StaticArraysCore.StaticArray{Tuple{3}, &lt;:Number, 1}}, TelecomUtils.ExtraOutput}"><code>get_pointing</code></a>, <a href="#TelecomUtils.get_lla-Tuple{ReferenceView, Union{Tuple{Number, Number}, StaticArraysCore.StaticArray{Tuple{2}, &lt;:Number, 1}}, TelecomUtils.ExtraOutput}"><code>get_lla</code></a>, <a href="#TelecomUtils.get_ecef-Tuple{ReferenceView, Union{Tuple{Number, Number}, StaticArraysCore.StaticArray{Tuple{2}, &lt;:Number, 1}}, TelecomUtils.ExtraOutput}"><code>get_ecef</code></a>, <a href="#TelecomUtils.get_distance_on_earth-Tuple{LLA, LLA, TelecomUtils.ExtraOutput}"><code>get_distance_on_earth</code></a>, <a href="#TelecomUtils.get_visibility-Tuple{ReferenceView, Union{LLA, Tuple{Number, Number, Number}, StaticArraysCore.StaticArray{Tuple{3}, &lt;:Number, 1}}, TelecomUtils.ExtraOutput}"><code>get_visibility</code></a>, <a href="#TelecomUtils.get_mutual_visibility-Tuple{ReferenceView, ReferenceView, TelecomUtils.ExtraOutput}"><code>get_mutual_visibility</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/disberd/TelecomUtils.jl/blob/298af29cfbedee573e0fb7f70ddae3f180392cfa/notebooks/refview_struct.jl#L665-L685">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TelecomUtils.get_range-Tuple{ReferenceView, Union{Tuple{Number, Number}, StaticArraysCore.StaticArray{Tuple{2}, &lt;:Number, 1}}, TelecomUtils.ExtraOutput}" href="#TelecomUtils.get_range-Tuple{ReferenceView, Union{Tuple{Number, Number}, StaticArraysCore.StaticArray{Tuple{2}, &lt;:Number, 1}}, TelecomUtils.ExtraOutput}"><code>TelecomUtils.get_range</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_range(rv::ReferenceView,uv::Point2D[, ::ExtraOutput]; h = 0.0, face = rv.face, R = nothing)
get_range(rv::ReferenceView,target::Union{LLA, Point3D, ReferenceView}[, ::ExtraOutput]; face = rv.face, R = nothing)</code></pre><p>Get the range [in m] between the reference view <code>rv</code> (Satellite or User) and a target point. The target point can be identified in two ways:</p><ul><li>Providing the uv pointing <code>uv</code> and the reference altitude <code>h</code> [m] above the ellipsoid (first method)</li><li>directly passing in a point expressed either as <code>LLA</code>, as a <code>Point3D</code> representing its ECEF coordinates, or as another instance of <code>ReferenceView</code> (second method).</li></ul><p>The pointing is assumed to be referred to the specified <code>face</code> of the <code>ReferenceView</code>. When the location identified by the provided pointing is not visible either because it&#39;s blocked by earth or because it&#39;s in a direction not visible from the specified <code>face</code>, <code>NaN</code> is returned.</p><p>See <a href="#TelecomUtils.change_reference_face!-Tuple{ReferenceView, Any}"><code>change_reference_face!</code></a> for supported identification of the <code>face</code> kwarg.</p><p>When called with an instance of <code>TelecomUtils.ExtraOutput</code> as last argument, the function also returns the coordinated of the identified point in the local CRS of <code>rv</code>.</p><p>The kwarg <code>R</code> represents the 3D Rotation Matrix that translates a vector from ECEF coordinates to the coordinates of the desired local CRS around <code>rv</code>. By default (if <code>R === nothing</code>) this rotation matrix is computed based on the rotation matrix of the <code>rv</code> object and on the selected reference face.</p><p>See also: <a href="#TelecomUtils.ReferenceView"><code>ReferenceView</code></a>, <a href="#TelecomUtils.get_era-Tuple{UserView, Union{LLA, Tuple{Number, Number, Number}, StaticArraysCore.StaticArray{Tuple{3}, &lt;:Number, 1}, ReferenceView}}"><code>get_era</code></a>, <a href="#TelecomUtils.get_mutual_pointing-Tuple{ReferenceView, ReferenceView, TelecomUtils.ExtraOutput}"><code>get_mutual_pointing</code></a>, <a href="#TelecomUtils.get_pointing-Tuple{ReferenceView, Union{LLA, Tuple{Number, Number, Number}, StaticArraysCore.StaticArray{Tuple{3}, &lt;:Number, 1}}, TelecomUtils.ExtraOutput}"><code>get_pointing</code></a>, <a href="#TelecomUtils.get_lla-Tuple{ReferenceView, Union{Tuple{Number, Number}, StaticArraysCore.StaticArray{Tuple{2}, &lt;:Number, 1}}, TelecomUtils.ExtraOutput}"><code>get_lla</code></a>, <a href="#TelecomUtils.get_ecef-Tuple{ReferenceView, Union{Tuple{Number, Number}, StaticArraysCore.StaticArray{Tuple{2}, &lt;:Number, 1}}, TelecomUtils.ExtraOutput}"><code>get_ecef</code></a>, <a href="#TelecomUtils.get_distance_on_earth-Tuple{LLA, LLA, TelecomUtils.ExtraOutput}"><code>get_distance_on_earth</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/disberd/TelecomUtils.jl/blob/298af29cfbedee573e0fb7f70ddae3f180392cfa/notebooks/refview_struct.jl#L503-L528">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TelecomUtils.get_visibility-Tuple{ReferenceView, Union{LLA, Tuple{Number, Number, Number}, StaticArraysCore.StaticArray{Tuple{3}, &lt;:Number, 1}}, TelecomUtils.ExtraOutput}" href="#TelecomUtils.get_visibility-Tuple{ReferenceView, Union{LLA, Tuple{Number, Number, Number}, StaticArraysCore.StaticArray{Tuple{3}, &lt;:Number, 1}}, TelecomUtils.ExtraOutput}"><code>TelecomUtils.get_visibility</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_visibility(rv::ReferenceView, target::Union{LLA, Point3D, ReferenceView}[, ::ExtraOutput]; boresight = rv.face, fov = 90°)</code></pre><p>Returns <code>true</code> if <code>target</code> is visible from <code>rv</code> assuming an antenna boresight direction specified by <code>boresight</code> and a maximum Field of View from the boresight specified by <code>fov</code>.</p><p>The <code>boresight</code> kwarg can be specified either as a <code>face</code> (compatible with the input types specified in <a href="#TelecomUtils.change_reference_face!-Tuple{ReferenceView, Any}"><code>change_reference_face!</code></a>) or as a 3D pointing vector using either 3 elements Tuple, Vector or SVector. If a 3D vector is provided, the function normalizes to unitary norm automatically.</p><p>The <code>fov</code> kwarg must be specified as an angle in radians if provided as a simple Number. To provide a fov in degress, directly use ° from Unitful re-exported by TelecomUtils.</p><p>When called with an instance of <code>TelecomUtils.ExtraOutput</code> as last argument, the function also returns the pointing angle θ between <code>rv</code> and <code>target</code> as second argument, and the direction in ECEF coordinates from <code>rv</code> to <code>target</code>.</p><p>See also: <a href="#TelecomUtils.get_pointing-Tuple{ReferenceView, Union{LLA, Tuple{Number, Number, Number}, StaticArraysCore.StaticArray{Tuple{3}, &lt;:Number, 1}}, TelecomUtils.ExtraOutput}"><code>get_pointing</code></a>, <a href="#TelecomUtils.get_mutual_pointing-Tuple{ReferenceView, ReferenceView, TelecomUtils.ExtraOutput}"><code>get_mutual_pointing</code></a>, <a href="#TelecomUtils.ReferenceView"><code>ReferenceView</code></a>, <a href="#TelecomUtils.get_range-Tuple{ReferenceView, Union{Tuple{Number, Number}, StaticArraysCore.StaticArray{Tuple{2}, &lt;:Number, 1}}, TelecomUtils.ExtraOutput}"><code>get_range</code></a>, <a href="#TelecomUtils.get_pointing-Tuple{ReferenceView, Union{LLA, Tuple{Number, Number, Number}, StaticArraysCore.StaticArray{Tuple{3}, &lt;:Number, 1}}, TelecomUtils.ExtraOutput}"><code>get_pointing</code></a>, <a href="#TelecomUtils.get_lla-Tuple{ReferenceView, Union{Tuple{Number, Number}, StaticArraysCore.StaticArray{Tuple{2}, &lt;:Number, 1}}, TelecomUtils.ExtraOutput}"><code>get_lla</code></a>, <a href="#TelecomUtils.get_ecef-Tuple{ReferenceView, Union{Tuple{Number, Number}, StaticArraysCore.StaticArray{Tuple{2}, &lt;:Number, 1}}, TelecomUtils.ExtraOutput}"><code>get_ecef</code></a>, <a href="#TelecomUtils.get_distance_on_earth-Tuple{LLA, LLA, TelecomUtils.ExtraOutput}"><code>get_distance_on_earth</code></a>, <a href="#TelecomUtils.get_mutual_visibility-Tuple{ReferenceView, ReferenceView, TelecomUtils.ExtraOutput}"><code>get_mutual_visibility</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/disberd/TelecomUtils.jl/blob/298af29cfbedee573e0fb7f70ddae3f180392cfa/notebooks/refview_struct.jl#L907-L930">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TelecomUtils.lin2db-Tuple{Real}" href="#TelecomUtils.lin2db-Tuple{Real}"><code>TelecomUtils.lin2db</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">lin2db(x::Real) -&gt; Any
</code></pre><p>Convert a number from linear to dB</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/disberd/TelecomUtils.jl/blob/298af29cfbedee573e0fb7f70ddae3f180392cfa/notebooks/utils.jl#L205">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TelecomUtils.new_color_order-Tuple{Int64, Dictionaries.Dictionary{StaticArraysCore.SVector{2, I}, I} where I, Any}" href="#TelecomUtils.new_color_order-Tuple{Int64, Dictionaries.Dictionary{StaticArraysCore.SVector{2, I}, I} where I, Any}"><code>TelecomUtils.new_color_order</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">new_color_order(n::Int64, color_order_dict::Dictionaries.Dictionary{StaticArraysCore.SVector{2, I}, I} where I, F) -&gt; Vector
</code></pre><p>Find the new optimal color ordering when starting from color <code>n</code> rather than from 1.</p><p><strong>Arguments</strong></p><ul><li><code>n</code> → New starting color.</li><li><code>color_order_dict</code> → original optimal color order for the current coloring scheme obtained via <a href="#TelecomUtils.get_color_illumination_order-Tuple{Any}"><code>get_color_illumination_order</code></a>.</li><li><code>F</code> → lattice generating matrix for the current coloring scheme, obtained using <a href="@ref"><code>generate_F_reuse_matrix</code></a>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/disberd/TelecomUtils.jl/blob/298af29cfbedee573e0fb7f70ddae3f180392cfa/notebooks/utils.jl#L410">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TelecomUtils.snr2speff-Tuple{DVBS2x, Any}" href="#TelecomUtils.snr2speff-Tuple{DVBS2x, Any}"><code>TelecomUtils.snr2speff</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">snr2speff(DVBS2x(), linear_snr)
snr2speff(Shannon(), linear_snr)
snr2speff(NR5G(), linear_snr)</code></pre><p>Computes the minimum the spectral efficiency <code>η</code> [b/s/Hz] that can be achieved given the input SNR [linear] <code>linear_snr</code>.</p><p>The first argument specifies whether to use the DVBS2x or 5G NR thresholds or the Shannon formula for the computation.</p><p>See also: <a href="#TelecomUtils.DVBS2x"><code>DVBS2x</code></a>, <a href="#TelecomUtils.Shannon"><code>Shannon</code></a>, <a href="#TelecomUtils.NR5G"><code>NR5G</code></a>, <a href="#TelecomUtils.speff2snr-Tuple{DVBS2x, Any}"><code>speff2snr</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/disberd/TelecomUtils.jl/blob/298af29cfbedee573e0fb7f70ddae3f180392cfa/notebooks/snr2speff.jl#L182-L191">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TelecomUtils.speff2snr-Tuple{DVBS2x, Any}" href="#TelecomUtils.speff2snr-Tuple{DVBS2x, Any}"><code>TelecomUtils.speff2snr</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">speff2snr(DVBS2x(), η)
speff2snr(Shannon(), η)
speff2snr(NR5G(), η)</code></pre><p>Computes the minimum SNR [linear] that is required to achieve the target spectral efficiency <code>η</code> [b/s/Hz].</p><p>The first argument specifies whether to use the DVBS2x or 5G NR thresholds or the Shannon formula for the computation</p><p>See also: <a href="#TelecomUtils.DVBS2x"><code>DVBS2x</code></a>, <a href="#TelecomUtils.Shannon"><code>Shannon</code></a>, <a href="#TelecomUtils.NR5G"><code>NR5G</code></a>, <a href="#TelecomUtils.snr2speff-Tuple{DVBS2x, Any}"><code>snr2speff</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/disberd/TelecomUtils.jl/blob/298af29cfbedee573e0fb7f70ddae3f180392cfa/notebooks/snr2speff.jl#L169-L178">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TelecomUtils.λ2f-Tuple{Real}" href="#TelecomUtils.λ2f-Tuple{Real}"><code>TelecomUtils.λ2f</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">λ2f(λ::Real) -&gt; Any
</code></pre><p>Get the frequency (in Hz) starting from the wavelength (in m) </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/disberd/TelecomUtils.jl/blob/298af29cfbedee573e0fb7f70ddae3f180392cfa/notebooks/utils.jl#L227">source</a></section></article></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Wednesday 24 May 2023 11:26">Wednesday 24 May 2023</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
