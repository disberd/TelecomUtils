var documenterSearchIndex = {"docs":
[{"location":"#TelecomUtils.jl","page":"TelecomUtils.jl","title":"TelecomUtils.jl","text":"","category":"section"},{"location":"","page":"TelecomUtils.jl","title":"TelecomUtils.jl","text":"Documentation for TelecomUtils.jl","category":"page"},{"location":"","page":"TelecomUtils.jl","title":"TelecomUtils.jl","text":"Modules = [TelecomUtils]\nPrivate = false\nOrder = [:type, :function]","category":"page"},{"location":"#TelecomUtils.DVBS2x","page":"TelecomUtils.jl","title":"TelecomUtils.DVBS2x","text":"DVBS2x <: CapacityComputationType\n\nStructure used to dispatch on speff2snr and snr2speff to simulate the MODCODs of the DVB-S2x air interface.\n\nNote\n\nThe threshold values are taken from the error performance chapter (6) of the DVB-S2x  standard assuming AWGN conditions\n\nSee also: Shannon, NR5G, speff2snr, snr2speff\n\n\n\n\n\n","category":"type"},{"location":"#TelecomUtils.ECEFfromENU","page":"TelecomUtils.jl","title":"TelecomUtils.ECEFfromENU","text":"Convert a point from ENU coordinates to ECEF ones\n\nFields\n\norigin::SVector{3,Float64}: ECEF coordinates of the reference CRS origin\nR::RotMatrix3{Float64}: Rotation matrix to align the source to the destination CRS axes\nellipsoid::Ellipsoid{Float64}: Reference ellipsoid used for the transformation between ECEF and other coordinates\n\n\n\n\n\n","category":"type"},{"location":"#TelecomUtils.ECEFfromERA","page":"TelecomUtils.jl","title":"TelecomUtils.ECEFfromERA","text":"Convert a point from ERA coordinates to ECEF ones\n\nFields\n\norigin::SVector{3,Float64}: ECEF coordinates of the reference CRS origin\nR::RotMatrix3{Float64}: Rotation matrix to align the source to the destination CRS axes\nellipsoid::Ellipsoid{Float64}: Reference ellipsoid used for the transformation between ECEF and other coordinates\n\n\n\n\n\n","category":"type"},{"location":"#TelecomUtils.ECEFfromUV","page":"TelecomUtils.jl","title":"TelecomUtils.ECEFfromUV","text":"Convert a point from UV coordinates to ECEF ones\n\nFields\n\norigin::SVector{3,Float64}: ECEF coordinates of the reference CRS origin\nR::RotMatrix3{Float64}: Rotation matrix to align the source to the destination CRS axes\nellipsoid::Ellipsoid{Float64}: Reference ellipsoid used for the transformation between ECEF and other coordinates\n\n\n\n\n\n","category":"type"},{"location":"#TelecomUtils.ENUfromECEF","page":"TelecomUtils.jl","title":"TelecomUtils.ENUfromECEF","text":"Convert a point from ECEF coordinates to ENU ones\n\nFields\n\norigin::SVector{3,Float64}: ECEF coordinates of the reference CRS origin\nR::RotMatrix3{Float64}: Rotation matrix to align the source to the destination CRS axes\nellipsoid::Ellipsoid{Float64}: Reference ellipsoid used for the transformation between ECEF and other coordinates\n\n\n\n\n\n","category":"type"},{"location":"#TelecomUtils.ERA","page":"TelecomUtils.jl","title":"TelecomUtils.ERA","text":"Elevation, Range and Azimuth for a target point on space as seen from a source point on or above the earth surface\n\nFields\n\nel::Float64: Elevation view angle (0 <= el <= π/2) between source and target point [rad].\nr::Float64: Range (r >= 0) between the source and target points [m].\naz::Float64: Azimuth view angle between source and target point [rad], computed from West to North from the source point perspective. Values provided are automatically converted between -π and π\n\nConstructors\n\nERA(el::ValidAngle,r::ValidDistance,az::ValidAngle)\n\nValidAngle is a either a Real number or a Unitful.Quantity of unit either u\"rad\" or u\"°\".\n\nValidDistance is either a Real Number, or a subtype of Unitful.Length.\n\n\n\n\n\n","category":"type"},{"location":"#TelecomUtils.ERAfromECEF","page":"TelecomUtils.jl","title":"TelecomUtils.ERAfromECEF","text":"Convert a point from ECEF coordinates to ERA ones\n\nFields\n\norigin::SVector{3,Float64}: ECEF coordinates of the reference CRS origin\nR::RotMatrix3{Float64}: Rotation matrix to align the source to the destination CRS axes\nellipsoid::Ellipsoid{Float64}: Reference ellipsoid used for the transformation between ECEF and other coordinates\n\n\n\n\n\n","category":"type"},{"location":"#TelecomUtils.EarthModel","page":"TelecomUtils.jl","title":"TelecomUtils.EarthModel","text":"mutable struct EarthModel\n\nGeometrical model of the Earth ellipsoid to be used for all the view angles between satellite and points on earth.\n\nFields\n\nellipsoid::Ellipsoid{Float64}\nEllipsoid structure, used for the various point of view conversion. Default: SphericalEllipsoid()\ngeod::Proj4.geod_geodesic\nExtended geod structure, used for the inverse geodesic problem to compute distance and azimuth between points on earth. (Relies on GeographicLib). Default: Proj4.geod_geodesic(ellipsoid)\n\nA single instance of this structure should be used for all satellites of a given simulation/constellation.\nChanges to any of the two fields (via setproperty!) will trigger an automatic recomputation of the other field.\nWhen called without arguments, it defaults to a spherical earth with a radius of 6371 km.\n\nSee also: Ellipsoid, SphericalEllipsoid, SatView\n\n\n\n\n\n","category":"type"},{"location":"#TelecomUtils.LLA","page":"TelecomUtils.jl","title":"TelecomUtils.LLA","text":"Identify a point on or above earth using geodetic coordinates\n\nFields\n\nlat::Float64: Latitude (-π/2 <= lat <= π/2) of the point [rad].\nlon::Float64: Longitude of the point [rad].\nalt::Float64: Altitude of the point above the reference earth ellipsoid [m].\n\nConstructors\n\nLLA(lat::ValidAngle,lon::ValidAngle,alt::ValidDistance)\nLLA(lat::ValidAngle,lon::ValidAngle) # Defaults to 0m altitude\n\nValidAngle is a either a Real number or a Unitful.Quantity of unit either u\"rad\" or u\"°\".\n\nValidDistance is either a Real Number, or a subtype of Unitful.Length.\n\n\n\n\n\n","category":"type"},{"location":"#TelecomUtils.LLAfromUV","page":"TelecomUtils.jl","title":"TelecomUtils.LLAfromUV","text":"Convert a point from UV coordinates to LLA ones\n\nFields\n\norigin::SVector{3,Float64}: ECEF coordinates of the reference CRS origin\nR::RotMatrix3{Float64}: Rotation matrix to align the source to the destination CRS axes\nellipsoid::Ellipsoid{Float64}: Reference ellipsoid used for the transformation between ECEF and other coordinates\n\n\n\n\n\n","category":"type"},{"location":"#TelecomUtils.NR5G","page":"TelecomUtils.jl","title":"TelecomUtils.NR5G","text":"NR5G <: CapacityComputationType\n\nStructure used to dispatch on speff2snr and snr2speff to simulate the MODCODs of the 5G NR air interface.\n\nNote\n\nThe thresholds for the 5G approximation are taken from a document by Intel that can be found at this link. The document present a picture of the spectral efficiency vs SNR for various 5G NR MODCODs.\n\nAs the tabular data is not provided in the document, the points are extrapolated from the image using this tool. \n\nThe thresholds extrapolated from the image with the tool are increased by 1dB, since the values from the picture refer to 10% BLER (Block Error Rate), and we want to use something more akin to QEF (Quasi Error Free) as done for the DVB-S2x thresholds.\n\nFor this reason, the results for snr2speff and speff2snr for the 5G NR waveforms will be a linear interpolation based on the extrapolated values, rather than a step function corresponding to existing MODCODs\n\nSee also: DVBS2x, Shannon, speff2snr, snr2speff\n\n\n\n\n\n","category":"type"},{"location":"#TelecomUtils.ReferenceView","page":"TelecomUtils.jl","title":"TelecomUtils.ReferenceView","text":"rv = ReferenceView{T}(lla_or_ecef::Union{LLA, Point3D},earthmodel::EarthModel; kwargs...)\n\nA ReferenceView instance rv tracks the instantaneous position and orientation of an object in space or on earth. It is used to provide convenience methods to assess pointing, distance and visibility between obejcts. It can also be used to extract 3D coordinates (LLA or ECEF) based on pointing angles from the ReferenceView instance.\n\nWhen initializing rv, two convenience aliases can be used:\n\nUserView === ReferenceView{:User} can be used to represent users\nSatView === ReferenceView{:Satellite} can be used to represent satellites\n\nThe main difference between the two is that the default local CRS for computing pointing and visibilities is West-North-Down (+Z towards nadir) for SatView while it's East-North-Up (+Z towards Zenith) for UserView.\n\nFields\n\necef::StaticArraysCore.SVector{3, Float64}\nECEF coordinates of the current satellite position\nlla::LLA\nLLA coordinates of the current satellite position\nearthmodel::EarthModel\nReference EarthModel used for the projections and for the geodesic computations\nR::Rotations.RotMatrix3{Float64}\nRotation Matrix to go from the default local CRS to the ECEF CRS\nrot_z::Float64\nRotation angle [rad] about the z axis to bring the default local CRS to the current one\nrot_y::Float64\nRotation angle [rad] about the y axis to bring the default local CRS to the current one\nrot_x::Float64\nRotation angle [rad] about the x axis to bring the default local CRS to the current one\nface::TelecomUtils.Faces\nReference race of the satellite used for the pointing computations\n\nWhen multiple ReferenceView objects have to be modelled/tracked, the earthmodel field of all of them should point to the same EarthModel instance, so it should be generated once and then passed to the constructor of all the ReferenceView instances to ensure that all the objects are referring to the same earth model.\nDoing so will enforce the same Ellipsoid is shared between all satellites even when it is changed from one of the SatView instances.\n\nTo understand how the fields rot_z, rot_y and rot_x are used to model the rotation applied to the default local CRS to the intended one, see the documentation of crs_rotation\n\nThe possible values for the reference face (defined with respect to the axes of the local CRS) used for pointing/visibility computations can be found looking at change_reference_face!\n\nSee also: change_position!, change_attitude!, change_reference_face!, get_range, get_pointing, get_lla, get_ecef, geod_inverse, get_distance_on_earth, get_nadir_beam_diameter, ExtraOutput, get_visibility, get_mutual_visibility.\n\n\n\n\n\n","category":"type"},{"location":"#TelecomUtils.Shannon","page":"TelecomUtils.jl","title":"TelecomUtils.Shannon","text":"Shannon <: CapacityComputationType\n\nStructure used to dispatch on speff2snr and snr2speff to decide the method to use for the computation\n\nSee also: DVBS2x, NR5G, speff2snr, snr2speff\n\n\n\n\n\n","category":"type"},{"location":"#TelecomUtils.UVfromECEF","page":"TelecomUtils.jl","title":"TelecomUtils.UVfromECEF","text":"Convert a point from ECEF coordinates to UV ones\n\nFields\n\norigin::SVector{3,Float64}: ECEF coordinates of the reference CRS origin\nR::RotMatrix3{Float64}: Rotation matrix to align the source to the destination CRS axes\nellipsoid::Ellipsoid{Float64}: Reference ellipsoid used for the transformation between ECEF and other coordinates\n\n\n\n\n\n","category":"type"},{"location":"#TelecomUtils.UVfromLLA","page":"TelecomUtils.jl","title":"TelecomUtils.UVfromLLA","text":"Convert a point from LLA coordinates to UV ones\n\nFields\n\norigin::SVector{3,Float64}: ECEF coordinates of the reference CRS origin\nR::RotMatrix3{Float64}: Rotation matrix to align the source to the destination CRS axes\nellipsoid::Ellipsoid{Float64}: Reference ellipsoid used for the transformation between ECEF and other coordinates\n\n\n\n\n\n","category":"type"},{"location":"#TelecomUtils.SphericalEllipsoid","page":"TelecomUtils.jl","title":"TelecomUtils.SphericalEllipsoid","text":"SphericalEllipsoid(r = 6371e3)\n\nDefine a spherical ellipsoid of radius r to be used for the various transformation in SatView. Defaults to 6371km radius\n\n\n\n\n\n","category":"function"},{"location":"#TelecomUtils.add_angular_offset-Tuple{Any, Any}","page":"TelecomUtils.jl","title":"TelecomUtils.add_angular_offset","text":"p = add_angular_offset(p₀, offset_angles; input_type = :UV, output_type = :UV)\np = add_angular_offset(p₀, θ::ValidAngle, φ::ValidAngle = 0.0; input_type = :UV, output_type = :UV)\n\nCompute the resulting pointing direction p obtained by adding an angular offset specified by angles θ, φ (following the ISO/Physics convention for spherical coordinates) [rad] to the starting position identified by p₀.\n\nThe input starting position p₀ can be specified as any iterable of 2 elements and is interpreted (depending on the value of the input_type kwarg) as a set of 2D coordinates specified either as U-V or Theta-Phi [rad]. \n\nThe output pointing p is always provided as a SVector{2, Float64} and similarly to p₀ can be given as either UV or ThetaPhi coordinates depending on the value of the output_type kwarg.\n\nFor both input_type and output_type, the following Symbols are supported:\n\n:thetaphi, :ThetaPhi and :θφ can be used to represent pointing in ThetaPhi\n:UV and :uv can be used to represent pointing in UV\n\nThe offset angles can be provided either as 2nd and 3rd argument to the function (2nd method) or as an iterable containing θ and φ as first and second element respectively (1st method).\n\nThis function performs the inverse operation of get_angular_offset so the following code should return true\n\nuv1 = (.3,.4)\nuv2 = (-.2,.5)\noffset = get_angular_offset(uv1, uv2; input_type = :uv, output_type = :thetaphi)\np = add_angular_offset(uv1, offset; input_type = :uv, output_type = :uv)\nall(p .≈ uv2)\n\nSee also: get_angular_offset, get_angular_distance\n\n\n\n\n\n","category":"method"},{"location":"#TelecomUtils.change_attitude!-Tuple{ReferenceView}","page":"TelecomUtils.jl","title":"TelecomUtils.change_attitude!","text":"change_attitude!(rv::ReferenceView; rot_z = 0.0, rot_y = 0.0, rot_x = 0.0)\n\nModify the attitude (local CRS orientation) of rv by recomputing its internal rotation matrix as a product of the default location based one and the attitude rotation based on rot_z, rot_y and rot_x.\n\nSee crs_rotation for details on how the attitude rotation matrix is defined and computed.\n\nSee also ReferenceView, change_position!, change_Reference_face!\n\n\n\n\n\n","category":"method"},{"location":"#TelecomUtils.change_position!-Tuple{ReferenceView, Any, LLA, Any, Any, Any, Any}","page":"TelecomUtils.jl","title":"TelecomUtils.change_position!","text":"change_position!(rv::ReferenceView, ecef, lla::LLA, R, rot_z, rot_x, rot_y)\nchange_position!(rv::ReferenceView, ecef::Point3D, lla::LLA; rot_z = 0.0, rot_y = 0.0, rot_x = 0.0)\nchange_position!(rv::ReferenceView, lla::LLA; rot_z = 0.0, rot_y = 0.0, rot_x = 0.0)\nchange_position!(rv::ReferenceView, ecef::Point3D; rot_z = 0.0, rot_y = 0.0, rot_x = 0.0)\n\nChange the position of a ReferenceView object rv, also returning as output the modified rv.  The function mutates the ecef, lla, R, rot_z, rot_y, rot_x fields of the rv object with the values provided as arguments (when using the 1st method above).\nFor the remaining methods, the missing arguments are computed automatically.\n\nOne would normally use one of the last 3 methods so that the rotation matrix (and eventually either ECEF or LLA) are correctly computed by the function.\n\nThe first method avoids any computations but does not validate that provided inputs are correct/consistent and refer to the same position in space. For this reason it should only be used if those values are correctly pre-computed elsewhere and one wants to avoid the duplicate computations. \n\nNote: rot_z, rot_y and rot_x are used to obtain the actual reference CRS to use for the pointing computations. These angles are used to transform the default CRS (which is WND for SatView and ENU for UserView) into the desired CRS. This is done performing a z-y-x intrinsic rotation of the default CRS following the Tait-Bryan Definition.\n\nSee also: ReferenceView, get_range, get_pointing, get_lla, get_ecef, get_ecef.\n\n\n\n\n\n","category":"method"},{"location":"#TelecomUtils.change_reference_face!-Tuple{ReferenceView, Any}","page":"TelecomUtils.jl","title":"TelecomUtils.change_reference_face!","text":"change_reference_face!(rv::ReferenceView, face)\n\nModify the reference face that is used to compute the visibilities from object rv. The face can be specified using an instance of TelecomUtils.Faces (not exported), a Symbol or an Int as follows:   \n\nTelecomUtils.PositiveX or :PositiveX or 1\nTelecomUtils.PositiveY or :PositiveY or 2\nTelecomUtils.PositiveZ  or :PositiveZ or 3\nTelecomUtils.NegativeX or :NegativeX or -1\nTelecomUtils.NegativeY or :NegativeY or -2\nTelecomUtils.NegativeZ or :NegativeZ or -3\n\nSee also ReferenceView, change_position!, change_attitude!\n\n\n\n\n\n","category":"method"},{"location":"#TelecomUtils.compute_sat_position-Tuple{ECEFfromERA, Any, Any}","page":"TelecomUtils.jl","title":"TelecomUtils.compute_sat_position","text":"compute_sat_position(era2ecef::ECEFfromERA, el, az; h)\ncompute_sat_position(lla::LLA, el, az; h)\ncompute_sat_position(ecef::StaticVector{3}, el, az; h)\n\nGiven a ECEFfromERA transformation, a target elevation el and azimuth az, and a reference height h [m] of the satellite from the orbit center, provides the ECEF coordinates of the satellite that is seen with angles el and az from the origin of the era2ecef instance at an orbit altitude of h (computed from the earth/orbit center, not from the earth surface).\n\nIf called with an LLA or ECEF coordinate as the first argument, it automatically constructs the ECEFfromERA instance era2ecef with the provided coordinate as origin.\n\nNote\n\nThe values el and az are used internally to construct ERA objects, so are to be given in [rad] or specified in degrees using ° from Unitful, which is also exported by TelecomUtils.\n\nSee also: ERA, ECEF, LLA, ERAfromECEF, ECEFfromERA\n\n\n\n\n\n","category":"method"},{"location":"#TelecomUtils.crs_rotation-Tuple{}","page":"TelecomUtils.jl","title":"TelecomUtils.crs_rotation","text":"R = crs_rotation(;rot_x=0.0, rot_y=0.0, rot_z=0.0)\n\nCreate the z-y'-x'' intrinsic Tait-Bryan rotation matrix used to transform/rotate a starting CRS to another one. This is used within ReferenceView to account for satellite attitude or user pointing when defining the final satellite/user centric CRS.\n\nTaking as example a SatView, the default CRS without any attitude rotation is always the WND one centered on the satellite, with the X axis pointing towards West, Y axis towards north and Z axis towards nadir.\n\nLet's call this default CRS as WND and let's assume to have a satellite in a LEO orbit with an inclination of 70 degrees. Let's assume that the satellite is at its ascending node, and that we want to rotate the CRS of the satellite so that the Y axis points in the direction of propagation. To create this new CRS that we will call XYZ, we have to rotate the WND one by 20 degrees clock-wise around the Z axis of the WND CRS.\n\nAssuming to have a point xyz in coordinates relative to the XYZ CRS, we can express the same point as wnd relative to the WND CRS with the following equation:\n\nwnd = crs_rotation(;rot_z=20°) * xyz\n\n\n\n\n\n","category":"method"},{"location":"#TelecomUtils.db2lin-Tuple{Real}","page":"TelecomUtils.jl","title":"TelecomUtils.db2lin","text":"db2lin(x::Real) -> Any\n\n\nConvert a number from dB to linear\n\n\n\n\n\n","category":"method"},{"location":"#TelecomUtils.f2λ-Tuple{Real}","page":"TelecomUtils.jl","title":"TelecomUtils.f2λ","text":"f2λ(f::Real) -> Any\n\n\nGet the wavelength (in m) starting from the frequency (in Hz)\n\n\n\n\n\n","category":"method"},{"location":"#TelecomUtils.generate_colors","page":"TelecomUtils.jl","title":"TelecomUtils.generate_colors","text":"generate_colors(BeamCenters::AbstractVector,N_Colours::Int=4;lattice_type::Symbol=:triangular)\n\nProvide a the coloring breakdown for a given set of lattice points.\n\nArguments\n\nBeamCenters → Vector of Tuple or StaticVectors expressing the U-V coordinates of each point in the lattice for which the coloring is being computed\nN_Colours → Number of colors to divide the lattice in. Defaults to 4\n\nkeyword Arguments\n\nlattice_type → Symbol that can either be :triangular or :square, idenifying the type of lattice. Defaults to :triangular\n\n\n\n\n\n","category":"function"},{"location":"#TelecomUtils.generate_colors-NTuple{4, Any}","page":"TelecomUtils.jl","title":"TelecomUtils.generate_colors","text":"generate_colors(BeamCenters, colordict, L, F; first_color_idx, first_color_coord) -> Any\n\n\nProvide a the coloring breakdown for a given set of lattice points.\n\nArguments\n\nBeamCenters → Array of SVector{2,<:Number} points identifying the beam lattice centers\ncolordict → Dictionary of the optimal color order for the given coloring scheme, obtained using get_color_illumination_order\nL → Beam Lattice generating matrix, function of the beam spacing and lattice type and obtained using get_L\nF → Color Lattice generating matrix, function of the number of colors and beam lattice type and obtained using generate_F_reuse_matrix\n\nKeyword Arguments\n\nfirst_color_idx → Provide the index of the point in BeamCenters that should be associated with color 1.\nfirst_color_coord → Provide the coordinates of the point that should be associated with color 1, if both coord and idx are provided, the idx is ignored. Defaults to the giving color 1 to the point in (0,0).\n\nNote\n\nThe colors are ordered in such a way that if illuminating the colors in sequential order, the next color is always the one that has the maximum minimum distance with points of the previoulsy illuminated colors (so the one most likely to create lower interference).\n\n\n\n\n\n","category":"method"},{"location":"#TelecomUtils.generate_hex_lattice-Tuple{Real, Vararg{Any}}","page":"TelecomUtils.jl","title":"TelecomUtils.generate_hex_lattice","text":"generate_hex_lattice(spacing::Real[,f_cond];kwargs...)\n\nSummary\n\nGenerate a hexagonal lattice of points (with equal distance between neighboring points). The hexagonal lattice generated by this function has distance between points on the same column √3 times greater than the distance between points on the same row.\n\nArguments\n\nspacing → spacing between points\n\nSee generate_regular_lattice for a description of f_cond and of  the keyword arguments\n\n\n\n\n\n","category":"method"},{"location":"#TelecomUtils.generate_rect_lattice-Tuple{Real, Real, Vararg{Any}}","page":"TelecomUtils.jl","title":"TelecomUtils.generate_rect_lattice","text":"generate_rect_lattice(spacing_x::Real,spacing_y::Real[,f_cond];kwargs...)\n\nSummary\n\nGenerate a rectangular lattice of points (with different spacing among x and y directions)\n\nArguments\n\nspacing_x → spacing between points on the x axis\nspacing_y → spacing between points on the y axis\n\nSee generate_regular_lattice for a description of f_cond and of  the keyword arguments\n\n\n\n\n\n","category":"method"},{"location":"#TelecomUtils.generate_regular_lattice-Union{Tuple{T}, Tuple{T, T, T}, Tuple{T, T, T, Function}} where T<:Real","page":"TelecomUtils.jl","title":"TelecomUtils.generate_regular_lattice","text":"Generate a regular lattice of points\n\ngenerate_regular_lattice(dx::Real, dy::Real, ds::Real) -> Any\ngenerate_regular_lattice(dx::Real, dy::Real, ds::Real, f_cond::Function; x0, y0, M, N) -> Any\n\n\nArguments\n\ndx → element spacing on the x axis\ndy → element spacing on the y axis\nds → displacement along x between rows of elements\nf_cond::Function → function of two arguments (f(x,y) = ...) returning true if element at position x,y must be kept and false otherwise\n\nKeyord Arguments\n\nx0 = 0 → x coordinate of the origin of the lattice\ny0 = 0 → y coordinate of the origin of the lattice\nM::Int = 70 → Number of elements to generate per row of points before appliying the filtering function f_cond\nN::Int = M → Number of rows of points to generate before appliying the filtering function f_cond\n\n\n\n\n\n","category":"method"},{"location":"#TelecomUtils.generate_square_lattice-Tuple{Real, Vararg{Any}}","page":"TelecomUtils.jl","title":"TelecomUtils.generate_square_lattice","text":"generate_square_lattice(spacing::Real[,f_cond];kwargs...)\n\nSummary\n\nGenerate a square lattice of points (with equal spacing among x and y directions)\n\nArguments\n\nspacing → spacing between points on both x and y axis\n\nSee generate_regular_lattice for a description of f_cond and of  the keyword arguments\n\n\n\n\n\n","category":"method"},{"location":"#TelecomUtils.geod_inverse-Tuple{Proj4.geod_geodesic, AbstractVector{Float64}, AbstractVector{Float64}}","page":"TelecomUtils.jl","title":"TelecomUtils.geod_inverse","text":"geod_inverse(geod::Proj4.geod_geodesic, lonlat1::AbstractVector{Cdouble}, lonlat2::AbstractVector{Cdouble})\ngeod_inverse(geod::Proj4.geod_geodesic, lla1::LLA, lla2::LLA)\ngeod_inverse(em::EarthModel, lla1::LLA, lla2::LLA)\n\nSolve the inverse geodesic problem.\n\nArgs\n\ng       → the geod_geodesic object specifying the ellipsoid.\nlonlat1 → point 1 (degrees), where lat ∈ [-90, 90], lon ∈ [-540, 540) \nlonlat2 → point 2 (degrees), where lat ∈ [-90, 90], lon ∈ [-540, 540) \n\nOutputs\n\ndist → distance between point 1 and point 2 (meters).\nazi1 → azimuth at point 1 (degrees) ∈ [-180, 180)\nazi2 → (forward) azimuth at point 2 (degrees) ∈ [-180, 180)\n\nRemarks\n\nIf either point is at a pole, the azimuth is defined by keeping the longitude fixed, writing lat = 90 +/- eps, and taking the limit as eps -> 0+.\n\n\n\n\n\n","category":"method"},{"location":"#TelecomUtils.get_L-Tuple{Any}","page":"TelecomUtils.jl","title":"TelecomUtils.get_L","text":"get_L(spacing; lattice_type) -> Any\n\n\nGet the lattice generating matrix as a function of the lattice_type and of the lattice spacing.\n\nlattice_type has to be either :triangular or :square\n\n\n\n\n\n","category":"method"},{"location":"#TelecomUtils.get_angular_distance-Tuple{Any, Any}","page":"TelecomUtils.jl","title":"TelecomUtils.get_angular_distance","text":"get_angular_distance(p₁, p₂; input_type=:UV, output_type=:thetaphi)\n\nCompute the angular distance between the target pointing direction p₂ and the starting pointing direction p₁. The two target pointings can be intepreted as either UV or ThetaPhi coordinates depending on the value of the input_type kwarg.\n\nThe output is a scalar that depending on the value of the output_type kwarg represents either the distance in UV, or the angular distance (Δθ) between p₂ and p₁.\n\nFor both input_type and output_type, the following Symbols are supported:\n\n:thetaphi, :ThetaPhi and :θφ can be used to represent pointing in ThetaPhi\n:UV and :uv can be used to represent pointing in UV\n\nNote\n\nAll input angles are intepreted as radians unless specified as a Quantity in degrees using ° from Unitful.\n\nThe output angles (when output_type is ThetaPhi) are also expressed in radians\n\nThis function is similar to get_angular_offset but has a slightly faster implementation in case only the distance is required, rather than the full 2D offset. The following code should evaluate to true\n\nuv1 = (.3,.4)\nuv2 = (-.2,.5)\noffset = get_angular_offset(uv1, uv2; input_type = :uv, output_type = :thetaphi)\nΔθ = get_angular_distance(uv1, uv2; input_type = :uv, output_type = :thetaphi)\noffset[1] ≈ Δθ\n\nSee also: add_angular_offset, get_angular_offset\n\n\n\n\n\n","category":"method"},{"location":"#TelecomUtils.get_angular_offset-Tuple{Any, Any}","page":"TelecomUtils.jl","title":"TelecomUtils.get_angular_offset","text":"get_angular_offset(p₁, p₂; input_type=:UV, output_type=:thetaphi)\n\nCompute the angular offset required to reach the target pointing direction p₂ from starting pointing direction p₁. The two target pointings can be intepreted as either UV or ThetaPhi coordinates depending on the value of the input_type kwarg.\n\nThe output is provided as an SVector{2,Float64} and depending on the value of the output_type kwarg it represents either the Δu, Δv offset in UV, or the angular offset (θ and φ) required to reach p₂ from p₁.\n\nFor both input_type and output_type, the following Symbols are supported:\n\n:thetaphi, :ThetaPhi and :θφ can be used to represent pointing in ThetaPhi\n:UV and :uv can be used to represent pointing in UV\n\nNote\n\nAll input angles are intepreted as radians unless specified as a Quantity in degrees using ° from Unitful.\n\nThe output angles (when output_type is ThetaPhi) are also expressed in radians\n\nThis function performs the inverse operation of add_angular_offset so the following code should return true\n\nuv1 = (.3,.4)\nuv2 = (-.2,.5)\noffset = get_angular_offset(uv1, uv2; input_type = :uv, output_type = :thetaphi)\np = add_angular_offset(uv1, offset; input_type = :uv, output_type = :uv)\nall(p .≈ uv2)\n\nCheck out get_angular_distance for a slightly faster implementation in case you only require the angular distance rather than the 2D offset.\n\nSee also: add_angular_offset, get_angular_distance\n\n\n\n\n\n","category":"method"},{"location":"#TelecomUtils.get_color_illumination_order-Tuple{Any}","page":"TelecomUtils.jl","title":"TelecomUtils.get_color_illumination_order","text":"get_color_illumination_order(N; lattice_type) -> Tuple{Dictionaries.Dictionary{StaticArraysCore.SVector{2, Int64}, Int64}, StaticArraysCore.SMatrix{2, 2, Int64, 4}}\n\n\nGet the illumination order to achieve maximum possible distance between already illuminated colors and next illuminated color.\n\nReturns a Dictionary associating each unique color vector obtained from get_deterministic_color_order to the ordering color. \n\n\n\n\n\n","category":"method"},{"location":"#TelecomUtils.get_distance_on_earth-Tuple{LLA, LLA, TelecomUtils.ExtraOutput}","page":"TelecomUtils.jl","title":"TelecomUtils.get_distance_on_earth","text":"get_distance_on_earth(sv::SatView, p1::Point2D, p2::Point2D[, ::ExtraOutput]; pointing_type::Symbol=:uv, face = sv.face, R)\nget_distance_on_earth(p1::LLA, p2::LLA[, ::ExtraOutput]; em = EarthModel())\nget_distance_on_earth(p1::UserView, p2::UserView)\n\nComputes the distance [m] between the points on the earth surface (lla1 and lla2) using the reference earth model used by sv.\n\nIf the points are not provided as LLA instances, but as angular directions (p1 and p2), lla1 and lla2 as first computed from p1 and p2 using the SatView object sv as reference.\n\nWhen called with angular directions, the optional argument kind is used to select whether the pointing is expressed in ThetaPhi (kind ∈ (:ThetaPhi, :thetaphi, :θφ)) [rad] or UV coordinates.\n\nIf an instance of ExtraOutput is provided as 4th argument, the function also returns the (forward) azimuth angle between lla1 and lla2 (2nd output, [deg]) and the azimuth angle between lla2 and lla1 (third output, [deg])\n\nSee also: SatView, get_range, get_pointing, get_lla, get_ecef, geod_inverse, get_nadir_beam_diameter, ExtraOutput.\n\n\n\n\n\n","category":"method"},{"location":"#TelecomUtils.get_ecef-Tuple{ReferenceView, Union{Tuple{Number, Number}, StaticArraysCore.StaticArray{Tuple{2}, <:Number, 1}}, TelecomUtils.ExtraOutput}","page":"TelecomUtils.jl","title":"TelecomUtils.get_ecef","text":"get_ecef(rv::ReferenceView, pointing::Point2D[, ::ExtraOutput]; pointing_type::Symbol=:uv, h = 0.0, face = rv.face, R = nothing)\n\nComputes the ECEF coordinates of the point that is seen by rv in the direction specified by pointing and is located at a target altitude h [m] above the earth's surface.\n\nIf a valid point can not be found because either earth is blocking the view or no point at altitude h can be seen from the provided pointing direction in the rv local CRS (also accounting for desired face), the function returns a SVector{3, Float64} filled win NaNs.\n\npointing_type is used to select whether the output is returned in UV or ThetaPhi [rad] coordinates. The following symbols are supported for this kwarg:\n\n:thetaphi, :ThetaPhi and :θφ can be used to represent pointing in ThetaPhi [rad]\n:UV and :uv can be used to represent pointing in UV\n\nWhen called with an instance of TelecomUtils.ExtraOutput as last argument, the function also returns the coordinated of the identified point in the local CRS of rv.\n\nFor details on how to modify the reference pointing direction using the kwargs face and R look at the documentation of get_range \n\nSee also: ReferenceView, get_range, get_pointing, get_lla, get_era, get_distance_on_earth, get_visibility, get_mutual_visibility.\n\n\n\n\n\n","category":"method"},{"location":"#TelecomUtils.get_era-Tuple{UserView, Union{LLA, Tuple{Number, Number, Number}, StaticArraysCore.StaticArray{Tuple{3}, <:Number, 1}, ReferenceView}}","page":"TelecomUtils.jl","title":"TelecomUtils.get_era","text":"get_era(uv::UserView, target::Union{LLA, Point3D, ReferenceView}[, ::ExtraOutput]; face = rv.face, R = nothing)\n\nComputes the ERA coordinates of the provided target as seen from the UserView uv. target can be given either as LLA/ECEF coordinates or directly as another ReferenceView\n\nFor details on how to modify the reference pointing direction using the kwargs face and R look at the documentation of get_range \n\nSee also: ReferenceView, get_range, get_pointing, get_lla, get_ecef, get_distance_on_earth.\n\n\n\n\n\n","category":"method"},{"location":"#TelecomUtils.get_lla-Tuple{ReferenceView, Union{Tuple{Number, Number}, StaticArraysCore.StaticArray{Tuple{2}, <:Number, 1}}, TelecomUtils.ExtraOutput}","page":"TelecomUtils.jl","title":"TelecomUtils.get_lla","text":"get_lla(rv::ReferenceView, pointing::Point2D[, ::ExtraOutput]; pointing_type::Symbol=:uv, h = 0.0, face = rv.face, R = nothing)\n\nComputes the LLA coordinates of the point that is seen by rv in the direction specified by pointing and is located at a target altitude h [m] above the earth's surface.\n\nIf a valid point can not be found because either earth is blocking the view or no point at altitude h can be seen from the provided pointing direction in the rv local CRS (also accounting for desired face), the function returns a SVector{3, Float64} filled win NaNs.\n\npointing_type is used to select whether the output is returned in UV or ThetaPhi [rad] coordinates. The following symbols are supported for this kwarg:\n\n:thetaphi, :ThetaPhi and :θφ can be used to represent pointing in ThetaPhi [rad]\n:UV and :uv can be used to represent pointing in UV\n\nWhen called with an instance of TelecomUtils.ExtraOutput as last argument, the function also returns the coordinated of the identified point in the local CRS of rv.\n\nFor details on how to modify the reference pointing direction using the kwargs face and R look at the documentation of get_range \n\nSee also: ReferenceView, get_range, get_pointing, get_lla, get_ecef, get_era, get_distance_on_earth, get_visibility, get_mutual_visibility.\n\n\n\n\n\n","category":"method"},{"location":"#TelecomUtils.get_mutual_pointing-Tuple{ReferenceView, ReferenceView, TelecomUtils.ExtraOutput}","page":"TelecomUtils.jl","title":"TelecomUtils.get_mutual_pointing","text":"p₁, p₂ = get_mutual_pointing(rv1::ReferenceView, rv2::ReferenceView[, ::ExtraOutput]; pointing_type::Symbol=:uv, faces = (rv1.face, rv2.face), Rs=(nothing, nothing), short_circuit = true)\n\nProvide the 2-D angular pointing in both directions between rv1 and rv2:\n\np₁ is the pointing of rv2 with respect to rv1\np₂ is the pointing of rv1 with respect to rv2\n\npointing_type is used to select whether the outputs are returned in UV or ThetaPhi [rad] coordinates. The following symbols are supported for this kwarg:\n\n:thetaphi, :ThetaPhi and :θφ can be used to represent pointing in ThetaPhi [rad]\n:UV and :uv can be used to represent pointing in UV\n\nWhen called with an instance of TelecomUtils.ExtraOutput as last argument, the function also returns the coordinated of the identified point in the local CRS of rv1 (or rv2). In this case:\n\np₁ is a tuple containing the pointing as first argument, the local CRS coordinates of rv2 with respect to rv1 as second argument and a NamedTuple with earth blockage data as third argument.\np₂ is a tuple containing the pointing as first argument, the local CRS coordinates of rv1 with respect to rv2 as second argument and a NamedTuple with earth blockage data as third argument.\n\nfaces and Rs are tuples containing the values of face and R for the two ReferenceView objects. faces[1] is used as reference face for rv1 while faces[2] is used for rv2. Similarly for Rs.\n\nThe short_circuit kwarg defaults to true and permits to return early from the function to save time.  When short_circuit == true, if the fwd pointing is false because of earth blockage, the function will directly return without computing the pointing on the return direction.\n\nFor details on how to modify the reference pointing direction using face and R look at the documentation of get_range \n\nSee also: ReferenceView, get_range, get_pointing, get_lla, get_ecef, get_distance_on_earth, get_visibility, get_mutual_visibility.\n\n\n\n\n\n","category":"method"},{"location":"#TelecomUtils.get_mutual_visibility-Tuple{ReferenceView, ReferenceView, TelecomUtils.ExtraOutput}","page":"TelecomUtils.jl","title":"TelecomUtils.get_mutual_visibility","text":"get_mutual_visibility(rv1::ReferenceView, rv2::ReferenceView[, ::ExtraOutput]; boresights = (rv1.face, rv2.face), fov = (90°, 90°), short_circuit = true)\n\nSimilar to get_visibility, returns true if rv1 and rv2 can see each other, assuming their antenna boresight directions to be specified by boresights and their maximum Field of View from the boresight to be specified by fovs.\n\nboresights and fovs are tuples containing the values of boresight and fov for the two ReferenceView objects. boresights[1] is used as reference boresight for rv1 while boresights[2] is used for rv2. Similarly for fovs.\n\nThe short_circuit kwarg defaults to true and permits to return early from the function to save time.  When short_circuit == true, if the fwd visibility is false, the function will directly return without computing the visibility angle on the return direction.\n\nEach boresight value inside the boresights kwarg can be specified either as a face (compatible with the input types specified in change_reference_face!) or as a 3D pointing vector using either 3 elements Tuple, Vector or SVector. If a 3D vector is provided, the function normalizes to unitary norm automatically.\n\nEach fov value inside the fovs kwarg must be specified as an angle in radians if provided as a simple Number. To provide a fov in degress, directly use ° from Unitful re-exported by TelecomUtils.\n\nWhen called with an instance of TelecomUtils.ExtraOutput as last argument, the function also returns a Tuple containing the full outputs (as if called with ExtraOutput) of get_visibility for each direction (rv1 to rv2 and vice-versa).\n\nSee also: get_pointing, get_mutual_pointing, ReferenceView, get_range, get_pointing, get_lla, get_ecef, get_distance_on_earth, get_visibility.\n\n\n\n\n\n","category":"method"},{"location":"#TelecomUtils.get_nadir_beam_diameter-Tuple{Any, Any}","page":"TelecomUtils.jl","title":"TelecomUtils.get_nadir_beam_diameter","text":"get_nadir_beam_diameter(sv, scan_3db)\n\n\nComputes the diameter [m] on earth of a beam pointed at nadir from the satellite position identified by sv and assuming a 3db beamwidth identified by the scan angle scan_3db [deg] at which the beam pattern is 3dB below the peak.\n\nThe computation computes the diameter along the U direction and takes into account the reference ellipsoid of sv, so the resulting diameter is dependent on the satellite lat/lon position\n\nSee also: SatView, get_range, get_pointing, get_lla, get_ecef, geod_inverse, get_distance_on_earth. \n\n\n\n\n\n","category":"method"},{"location":"#TelecomUtils.get_pointing-Tuple{ReferenceView, Union{LLA, Tuple{Number, Number, Number}, StaticArraysCore.StaticArray{Tuple{3}, <:Number, 1}}, TelecomUtils.ExtraOutput}","page":"TelecomUtils.jl","title":"TelecomUtils.get_pointing","text":"get_pointing(rv::ReferenceView, target::Union{LLA, Point3D, ReferenceView}[, ::ExtraOutput]; pointing_type::Symbol=:uv, face = rv.face, R=nothing)\n\nProvide the 2-D angular pointing at which the target point (specified as LLA, ECEF or as another ReferenceView) is seen from the ReferenceView object rv.\n\npointing_type is used to select whether the output is returned in UV or ThetaPhi [rad] coordinates. The following symbols are supported for this kwarg:\n\n:thetaphi, :ThetaPhi and :θφ can be used to represent pointing in ThetaPhi [rad]\n:UV and :uv can be used to represent pointing in UV\n\nWhen called with an instance of TelecomUtils.ExtraOutput as last argument, the function also returns the coordinated of the identified point in the local CRS of rv as second output, and a NamedTuple containing information on the earth blockage status as third argument.\n\nFor details on how to modify the reference pointing direction using the kwargs face and R look at the documentation of get_range \n\nSee also: get_mutual_pointing, ReferenceView, get_range, get_pointing, get_lla, get_ecef, get_distance_on_earth, get_visibility, get_mutual_visibility.\n\n\n\n\n\n","category":"method"},{"location":"#TelecomUtils.get_range-Tuple{ReferenceView, Union{Tuple{Number, Number}, StaticArraysCore.StaticArray{Tuple{2}, <:Number, 1}}, TelecomUtils.ExtraOutput}","page":"TelecomUtils.jl","title":"TelecomUtils.get_range","text":"get_range(rv::ReferenceView,uv::Point2D[, ::ExtraOutput]; h = 0.0, face = rv.face, R = nothing)\nget_range(rv::ReferenceView,target::Union{LLA, Point3D, ReferenceView}[, ::ExtraOutput]; face = rv.face, R = nothing)\n\nGet the range [in m] between the reference view rv (Satellite or User) and a target point. The target point can be identified in two ways:\n\nProviding the uv pointing uv and the reference altitude h [m] above the ellipsoid (first method)\ndirectly passing in a point expressed either as LLA, as a Point3D representing its ECEF coordinates, or as another instance of ReferenceView (second method).\n\nThe pointing is assumed to be referred to the specified face of the ReferenceView. When the location identified by the provided pointing is not visible either because it's blocked by earth or because it's in a direction not visible from the specified face, NaN is returned.\n\nSee change_reference_face! for supported identification of the face kwarg.\n\nWhen called with an instance of TelecomUtils.ExtraOutput as last argument, the function also returns the coordinated of the identified point in the local CRS of rv.\n\nThe kwarg R represents the 3D Rotation Matrix that translates a vector from ECEF coordinates to the coordinates of the desired local CRS around rv. By default (if R === nothing) this rotation matrix is computed based on the rotation matrix of the rv object and on the selected reference face.\n\nSee also: ReferenceView, get_era, get_mutual_pointing, get_pointing, get_lla, get_ecef, get_distance_on_earth.\n\n\n\n\n\n","category":"method"},{"location":"#TelecomUtils.get_visibility-Tuple{ReferenceView, Union{LLA, Tuple{Number, Number, Number}, StaticArraysCore.StaticArray{Tuple{3}, <:Number, 1}}, TelecomUtils.ExtraOutput}","page":"TelecomUtils.jl","title":"TelecomUtils.get_visibility","text":"get_visibility(rv::ReferenceView, target::Union{LLA, Point3D, ReferenceView}[, ::ExtraOutput]; boresight = rv.face, fov = 90°)\n\nReturns true if target is visible from rv assuming an antenna boresight direction specified by boresight and a maximum Field of View from the boresight specified by fov.\n\nThe boresight kwarg can be specified either as a face (compatible with the input types specified in change_reference_face!) or as a 3D pointing vector using either 3 elements Tuple, Vector or SVector. If a 3D vector is provided, the function normalizes to unitary norm automatically.\n\nThe fov kwarg must be specified as an angle in radians if provided as a simple Number. To provide a fov in degress, directly use ° from Unitful re-exported by TelecomUtils.\n\nWhen called with an instance of TelecomUtils.ExtraOutput as last argument, the function also returns the pointing angle θ between rv and target as second argument, and the direction in ECEF coordinates from rv to target.\n\nSee also: get_pointing, get_mutual_pointing, ReferenceView, get_range, get_pointing, get_lla, get_ecef, get_distance_on_earth, get_mutual_visibility.\n\n\n\n\n\n","category":"method"},{"location":"#TelecomUtils.lin2db-Tuple{Real}","page":"TelecomUtils.jl","title":"TelecomUtils.lin2db","text":"lin2db(x::Real) -> Any\n\n\nConvert a number from linear to dB\n\n\n\n\n\n","category":"method"},{"location":"#TelecomUtils.new_color_order-Tuple{Int64, Dictionaries.Dictionary{StaticArraysCore.SVector{2, I}, I} where I, Any}","page":"TelecomUtils.jl","title":"TelecomUtils.new_color_order","text":"new_color_order(n::Int64, color_order_dict::Dictionaries.Dictionary{StaticArraysCore.SVector{2, I}, I} where I, F) -> Vector\n\n\nFind the new optimal color ordering when starting from color n rather than from 1.\n\nArguments\n\nn → New starting color.\ncolor_order_dict → original optimal color order for the current coloring scheme obtained via get_color_illumination_order.\nF → lattice generating matrix for the current coloring scheme, obtained using generate_F_reuse_matrix.\n\n\n\n\n\n","category":"method"},{"location":"#TelecomUtils.snr2speff-Tuple{DVBS2x, Any}","page":"TelecomUtils.jl","title":"TelecomUtils.snr2speff","text":"snr2speff(DVBS2x(), linear_snr)\nsnr2speff(Shannon(), linear_snr)\nsnr2speff(NR5G(), linear_snr)\n\nComputes the minimum the spectral efficiency η [b/s/Hz] that can be achieved given the input SNR [linear] linear_snr.\n\nThe first argument specifies whether to use the DVBS2x or 5G NR thresholds or the Shannon formula for the computation.\n\nSee also: DVBS2x, Shannon, NR5G, speff2snr\n\n\n\n\n\n","category":"method"},{"location":"#TelecomUtils.speff2snr-Tuple{DVBS2x, Any}","page":"TelecomUtils.jl","title":"TelecomUtils.speff2snr","text":"speff2snr(DVBS2x(), η)\nspeff2snr(Shannon(), η)\nspeff2snr(NR5G(), η)\n\nComputes the minimum SNR [linear] that is required to achieve the target spectral efficiency η [b/s/Hz].\n\nThe first argument specifies whether to use the DVBS2x or 5G NR thresholds or the Shannon formula for the computation\n\nSee also: DVBS2x, Shannon, NR5G, snr2speff\n\n\n\n\n\n","category":"method"},{"location":"#TelecomUtils.λ2f-Tuple{Real}","page":"TelecomUtils.jl","title":"TelecomUtils.λ2f","text":"λ2f(λ::Real) -> Any\n\n\nGet the frequency (in Hz) starting from the wavelength (in m) \n\n\n\n\n\n","category":"method"}]
}
